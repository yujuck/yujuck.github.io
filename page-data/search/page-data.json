{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"깃헙 블로그로 다시 시작한게 지난달 6월 6일이였고 오늘이 벌써 7월 9일.. 시간은 진짜 빠르게 흘러간다ㅠㅠ 요즘 회사는 매일매일 일이 넘쳐나서 하루에 API 여러개씩 만들기도 하고,\n컬렉션 스키마도 작성하고 운영 업무도 보고 질문도 받고 그러느라 시간이 순식간에 지나간다. 블로그글 다시 쓰면서는 기초 개념들이나 문법들 내용 얼른얼른 넘어가고 다른 내용…","fields":{"slug":"/한달에 한번 마음 먹기/"},"frontmatter":{"date":"July 09, 2023","title":"한달에 한 번 마음 먹기","tags":["일상"]},"rawMarkdownBody":"\r\n깃헙 블로그로 다시 시작한게 지난달 6월 6일이였고 오늘이 벌써 7월 9일..  \r\n시간은 진짜 빠르게 흘러간다ㅠㅠ\r\n\r\n요즘 회사는 매일매일 일이 넘쳐나서 하루에 API 여러개씩 만들기도 하고,\r\n컬렉션 스키마도 작성하고 운영 업무도 보고 질문도 받고 그러느라 시간이 순식간에 지나간다.  \r\n블로그글 다시 쓰면서는 기초 개념들이나 문법들 내용 얼른얼른 넘어가고 다른 내용들 많이 봐야지\r\n라고 생각했는데, 회사 갔다오면 기운이 다 빠져서 뭔가 할 의욕이 안생김 흑흑ㅠㅠ\r\n\r\n이런저런 이유로 의욕이 사라진 것 같아서 다시 한번 마음을 먹어야 할 것 같다..!  \r\n의욕만 앞세워서 목표를 세우고 작심삼일 하는 사람에게  \r\n작심삼일을 사흘에 한번씩 하면 되지 않겠냐는 말처럼  \r\n한달 간격으로 다시 한번 의욕을 불어넣는 글을 써보는 것도 나쁘지 않을 듯..!\r\n\r\n더운 여름.. 7월 한달 일도 많고 주말에 약속도 많지만 다시 한 번 노력해보자고..!!!\r\n\r\n일단 es6 시리즈 먼저 끝내던가 신입분들 OJT 맞춰서 Back to basic 시리즈 진행하던가 좀 해보자..  \r\n이미 OJT가 많이 진행되었지만 그래도 해보자고...\r\n"},{"excerpt":"Set은 중복되지 않는 유일한 값들의 집합(set)이다. 배열(Array)과 유사하지만 차이점이 있다. 구분 Array Set 중복 값 포함 가능 여부 O X 요소의 순서가 유의미 O X 인덱스로 요소 접근 가능 O X Set를 활용하면 데이터의 중복을 제거하여 유일한 값들을 관리할 수 있다. 요소의 순서가 유의미하지 않기 때문에 인덱스로 요소를 접근할 …","fields":{"slug":"/230629.Set/"},"frontmatter":{"date":"June 29, 2023","title":"Set (ES6)","tags":["javascript","ES6"]},"rawMarkdownBody":"\r\nSet은 중복되지 않는 유일한 값들의 집합(set)이다. 배열(Array)과 유사하지만 차이점이 있다.\r\n\r\n| 구분                    | Array | Set |\r\n| ----------------------- | ----- | --- |\r\n| 중복 값 포함 가능 여부  | O     | X   |\r\n| 요소의 순서가 유의미    | O     | X   |\r\n| 인덱스로 요소 접근 가능 | O     | X   |\r\n\r\nSet를 활용하면 데이터의 중복을 제거하여 유일한 값들을 관리할 수 있다. 요소의 순서가 유의미하지 않기 때문에 인덱스로 요소를 접근할 수는 없다.\r\n\r\n## 주요 메서드와 프로퍼티\r\n\r\nSet에서 사용되는 메서드와 프로퍼티들이다.\r\n\r\n- new Set() : Set 객체 생성\r\n- set.add(value) : value 저장\r\n- set.has(value) : value를 포함하고 있는지 확인\r\n- set.delete(value) : value 요소 삭제\r\n- set.clear() : set 안의 모든 요소 제거\r\n- set.size : 요소 개수 반환\r\n\r\n## Set 객체 생성\r\n\r\nSet 생성자 함수로 생성한다. 인수를 전달하지 않으면 빈 Set 객체가 생성된다.\r\n\r\n```javascript\r\nconst set = new Set();\r\nconsole.log(set); // Set(0) {}\r\n```\r\n\r\nSet 생성자 함수는 이터러블을 인수로 전달받아 Set 객체를 생성하는데, 중복된 값이 있을 경우 해당 값은 요소로 저장되지 않는다.\r\n\r\n```javascript\r\nconst set1 = new Set([1, 2, 3, 3]);\r\nconsole.log(set1); // Set(3) {1, 2, 3}\r\n```\r\n\r\n## 요소 추가\r\n\r\nSet.prototype.add 메서드를 사용해 요소를 추가할 수 있다.\r\n\r\n```javascript\r\nconst set = new Set();\r\nset.add(5);\r\nconsole.log(set); // Set(1) { 5 }\r\n```\r\n\r\nadd 메서드는 새로 요소가 추가된 Set 객체를 반환하기 때문에 연속적으로 add 메서드를 호출할 수 있다.\r\n\r\n```javascript\r\nconst set = new Set();\r\n\r\nset.add(5).add(10);\r\nconsole.log(set); // Set(2) { 5, 10 }\r\n```\r\n\r\nSet 객체에 객체나 배열 같이 자바스크립트의 모든 값을 요소로 저장할 수 있다.\r\n\r\n```javascript\r\nconst set = new Set();\r\n\r\nset\r\n  .add(1)\r\n  .add(\"x\")\r\n  .add(true)\r\n  .add(undefined)\r\n  .add(null)\r\n  .add({})\r\n  .add([])\r\n  .add(() => {});\r\n```\r\n\r\n## 요소 존재 확인\r\n\r\nSet.prototype.has 메서드를 사용하여 요소가 존재하는지 확인할 수 있다.\r\n\r\n```javascript\r\nconst set = new Set([1, 2, 3, 4, 5]);\r\n\r\nconsole.log(set.has(4)); // true\r\nconsole.log(set.has(\"x\")); // false\r\n```\r\n\r\n## 요소 삭제\r\n\r\nSet.prototype.delete 메서드를 사용해 요소를 삭제할 수 있다.  \r\nSet은 위에서 말했던 것처럼 인덱스라는 개념이 없기 때문에 실제로 삭제할 값을 인수로 전달해줘야 한다.\r\n\r\n```javascript\r\nconst set = new Set([1, 2, 3]);\r\n\r\nset.delete(3);\r\nset.delete(2);\r\nconsole.log(set); // Set(1) {1}\r\n```\r\n\r\nadd와 다르게 delete는 삭제 성공 여부를 리턴(true/false)하기 때문에 delete를 연속적으로 호출할 수는 없다.\r\n\r\n## 요소 일괄 삭제\r\n\r\nSet.prototype.clear 메서드를 사용하여 모든 요소를 삭제할 수 있다.\r\n\r\n```javascript\r\nconst set = new Set([1, 2, 3]);\r\n\r\nset.clear();\r\nconsole.log(set); // Set(0) {}\r\n```\r\n\r\n## 요소 개수 확인\r\n\r\nSet.prototype.size 프로퍼티를 사용해 요소 개수를 확인할 수 있다.\r\n\r\n```javascript\r\nconst { size } = new Set([1, 2, 3, 4, 5, 5]);\r\nconsole.log(size); // 5\r\n```\r\n\r\n## 요소 순회\r\n\r\nSet.prototype.forEach 메서드를 사용해 요소를 순회할 수 있다. 콜백 함수와 forEach 메서드의 콜백 함수 내부에서 this로 사용할 객체를 인수로 전달한다.  \r\n콜백 함수는 3개의 인수를 전달받는데, 첫 번째, 두 번째 인수는 `현재 순회 중인 요소값`을 전달받고 세 번째 인수로는 현재 순회중인 Set 객체 자체를 전달받는다.\r\n\r\n```javascript\r\nconst set = new Set([1, 2, 3]);\r\n\r\nset.forEach((v, v2, set) => console.log(v, v2, set));\r\n```\r\n\r\n### 이터러블\r\n\r\nSet도 Map과 마찬가지로 이터러블하기 때문에 for...of문으로 순회할 수 있고, 스프레드 문법, 디스트럭처링도 적용할 수 있다.\r\n\r\nSet 객체가 순서에 의미가 없긴 하지만 순회하는 순서는 다른 이터러블 순회와 호환성을 유지하기 위해 요소가 추가된 순서를 따른다고 한다.\r\n\r\n```javascript\r\nconst set = new Set([1, 2, 3, 4, 5, 6]);\r\n\r\nfor (const value of set) {\r\n  console.log(value); // 1,2,3,4,5,6\r\n}\r\n\r\nconsole.log([...set]); // [1,2,3,4,5,6]\r\n\r\nconst [x, ...rest] = set;\r\nconsole.log(x, rest); // 1, [2,3,4,5,6]\r\n```\r\n\r\n## Array to Set\r\n\r\n배열을 Set 객체로 만드는 방법은 간단하게 그냥 배열을 Set 생성자 함수의 인자로 넘기면 된다.\r\n\r\n```javascript\r\nconst arr = [1, 2, 3, 4];\r\nconst set = new Set(arr);\r\n```\r\n\r\n주의할 점은 계속 말했던 것처럼 중복값이 있다면 삭제된다는 것이다.\r\n\r\n## Set to Array\r\n\r\nSet를 배열로 바꾸는 방법으로는 위에서 본 스프레드 연산자를 사용하는 방법이 있고,\r\n`Array.from()`을 사용할 수도 있다.\r\n\r\n```javascript\r\nconst arr = [...set];\r\nconst arr2 = Array.from(set);\r\n```\r\n\r\n## 집합 연산\r\n\r\nSet 객체는 수학적 집합을 구현하기 위한 자료구조로, 합집합, 교집합, 차집합 등을 구현할 수 있다.\r\n\r\n```javascript\r\nconst set1 = new Set([1, 2, 3, 4, 5]);\r\nconst set2 = new Set([2, 3, 5, 6, 7, 8]);\r\n\r\n// 합집합\r\nconst union = new Set([...set1, ...set2]);\r\nconsole.log([...union]); // [1, 2, 3, 4, 5, 6, 7, 8]\r\n\r\n// 교집합\r\nconst intersection = new Set([...set1].filter(value => set2.has(value)));\r\nconsole.log([...intersection]); // [2, 3, 5]\r\n\r\n// 차집합\r\nconst difference = new Set([...set1].filter(value => !set2.has(value)));\r\nconsole.log([...difference]); // [1, 4]\r\n```\r\n\r\n## 언제 활용해야할까 ?\r\n\r\nSet은 확실하게 중복 값을 제거할 때 사용을 하게 되는 것 같다.  \r\n근데 사실 그마저도 뭔가.. 음.. 우리 코드 작성할 때는 별로 그럴 일이 없었어서 사용된 곳이 거의 없긴 하다.\r\n뭔가 알고리즘 문제 풀 때야 좀 쓰는 것 같기도..?\r\n"},{"excerpt":"구현하려는 이메일 인증 플로우 간단하게 동작으로만 플로우차트를 그려봤다. (자세한 API 내부 동작 플로우 생략)  1. JWT 발급 회원가입 이메일 인증에 를 사용했다.  정보만 두고 으로 설정했다.\n처음에는 유효시간을 30분으로 설정하고 만료된 토큰이 포함된 링크로 접속하면 인증 메일을 다시 전달받을 수 있도록 하려고 했는데,\n팀원들과 상의하여 유효시…","fields":{"slug":"/230628-이메일 인증 구현.md/"},"frontmatter":{"date":"June 28, 2023","title":"NestJS와 AWS SES로 이메일 인증 구현하기","tags":["server","nodejs","NestJS","AWS"]},"rawMarkdownBody":"\r\n## 구현하려는 이메일 인증 플로우\r\n\r\n간단하게 동작으로만 플로우차트를 그려봤다. (자세한 API 내부 동작 플로우 생략)\r\n\r\n![회원가입 버튼 클릭 이후 플로우](join.jpg)\r\n\r\n## 1. JWT 발급\r\n\r\n회원가입 이메일 인증에 `JWT`를 사용했다.  \r\n`payload에는 email` 정보만 두고 `expiresIn을 24시간`으로 설정했다.\r\n처음에는 유효시간을 30분으로 설정하고 만료된 토큰이 포함된 링크로 접속하면 인증 메일을 다시 전달받을 수 있도록 하려고 했는데,\r\n팀원들과 상의하여 유효시간은 24시간으로 두고 그 안에 인증하지 않으면 유저 정보를 삭제하는걸로 정했다.  \r\n이렇게 한 이유는 이메일 인증이 회원가입의 최종 단계로서 인증이 되지 않으면 로그인을 할 수 없는데, 실제로 사용하려는 유저라면 보통 바로 인증하기 때문에 24시간 내에 하지 않았다는건 사용하려는 의지가 없다라고 판단해서 삭제하기로 했다.  \r\n다른 곳들은 어떻게 하는지 궁금해..\r\n\r\n이렇게 발급받은 JWT는 API에서 만료시간 email 정보를 얻기 위해 사용된다.\r\n\r\n## 2. 이메일 전송하기\r\n\r\n회사에서는 `AWS SES`를 이용하고 있다. 회원가입 이메일 인증을 위한 템플릿은 미리 만들어두고 메일 내 `이메일 인증 버튼`에는 templateData를 전달받을 수 있도록 설정해두었다.\r\n\r\n백엔드에서 만든 이메일 전송 API는 프론트에서 전달해주는 이메일 템플릿 타입, email 주소, templateData를 전달받아 이메일 전송 command를 생성하여 호출하는 역할을 하도록 만들었다.\r\n\r\n```typescript\r\ninterface ISendEmailBody {\r\n  template: string;\r\n  email: string;\r\n  templateData: string; // JSON.stringify\r\n}\r\n\r\nconst emailRequestData = {\r\n  Source: \"보내는 사람 이메일\",\r\n  Destination: {\r\n    ToAddresses: [email],\r\n  },\r\n  Template: template,\r\n  TemplateData: templateData ?? `{}`,\r\n};\r\nconst command = new SendTemplatedEmailCommand(emailRequestData);\r\nawait this.sesClient.send(emailCommand);\r\n```\r\n\r\n메일 내에 있는 이메일 인증 버튼에 백엔드 API의 endpoint를 설정하기 위해 templateData에는 템플릿에 설정한 변수(key)와 거기에 넣을 값을 객체 형태로 만든 후 string으로 전달해야한다.\r\n\r\n참고로 SendTemplatedEmailCommand 사용하면 templateData가 필수값인데, `''`, `'null'` 이런식으로 보내면 전송이 안되고 `{}` 이렇게 보내야 한다.\r\n\r\n<br />\r\n\r\n💡 Amazon Simple Email Service (SES)  \r\n사용자의 이메일 주소와 도메인을 사용해 이메일을 보내고 받기 위한 경제적이고 손쉬운 방법을 제공하는 이메일 플랫폼이다.\r\n\r\n## 3. 사용자 인증 상태 변경 API 호출\r\n\r\n![전송된 이메일](email.jpg)\r\n\r\n위처럼 이메일을 수신하면 사용자는 이메일 인증하기 버튼을 클릭해 인증하게 된다.  \r\n저 버튼의 href에는 백엔드 API의 endpoint가 정의된다.\r\n\r\n클릭해서 호출된 API는 사용자의 인증 상태를 변경해주는 API이다.  \r\n쿼리스트링으로 `token=<JWT>`을 받고,\r\n전달받은 JWT를 verify해서 확인을 하고 유효한 경우에만 다음으로 진행한다.\r\n\r\nJWT가 유효한 경우, 서비스 정책상 이메일 인증이 된 사용자만 로그인할 수 있도록 하고 있어서 이메일 인증 상태를 나타내는 필드를 true로 업데이트 해준다.\r\n\r\n그리고 24시간 내에 인증을 하지 못하면 유저 정보를 삭제하도록 하고 있기 때문에,  \r\n회원 가입 시 expiredAt을 24시간 이후로 설정하여 저장하고, (해당 필드는 ttl 설정 - mongoDB)\r\n이메일 인증이 되면 null로 변경해줘야 한다.\r\n\r\n## 4. 리다이렉트\r\n\r\n어떻게 해야하는건지 생각을 못했는데 아주 쉽게 해결된 부분이다.  \r\n사실 지금 생각해보니까 검색할 때 리다이렉트라고 검색해놓고 왜 response.redirect를 사용할 생각을 못했는지 의문...😅\r\n\r\nNestJS를 사용하고 있어 response 객체를 사용하진 않고 `@Redirect()`를 사용했다.\r\n\r\n```typescript\r\n@Redirect(\"리다이렉트 주소\")\r\n  async emailAuthentication(@Query('token') token: string) {\r\n    try {\r\n      return await this.authService.updateVerifiedStatus(token);\r\n    } catch (err) {\r\n      return { url: \"리다이렉트 주소\" }; // token 인증에 오류 발생하면 홈 화면으로 리다이렉트\r\n    }\r\n  }\r\n```\r\n\r\n에러 발생 시 `{url: \"리다이렉트 주소\"}`를 리턴하고 있는데,  \r\n이렇게 하면 위에 데코레이터에 사용한 주소가 아닌 새로 리턴한 주소로 리다이렉트 시킨다.  \r\n[공식 문서](https://docs.nestjs.com/controllers#redirection)를 참고하면 된다.\r\n\r\n## 마무리\r\n\r\n다행히 생각했던대로 만들어낼 수 있었던 것 같다.  \r\n다만 다른 곳에서는 유효시간을 두고 어떻게 인증하게 하는지는 조금 궁금함..  \r\n메일 전송 계속 다시 할 수 있게 하는지..\r\n\r\nAWS SES랑 redirect, forward는 다른 글에서 다시 한번 정리해보자~\r\n"},{"excerpt":"현재 상황 현재 회사에서 만들고 있는 서비스에서 이메일을 통한 인증 방식을 사용하는 부분이 두 군데 있다.\n회원가입 시 사용한 이메일을 인증하는 부분과 비밀번호를 찾을 때 전송된 메일을 통해서 들어온 경우에만 비밀번호 재설정을 할 수 있게 하는 부분이다. 지금은 단순히 이메일 내 버튼에 이동시킬 페이지 주소를 넣어놓고 클릭 시 해당 페이지로 이동하도록 되…","fields":{"slug":"/230627-이메일 인증 구현/"},"frontmatter":{"date":"June 27, 2023","title":"회원가입, 비밀번호 찾기 이메일 인증 어떻게 하지?","tags":["server","nodejs","NestJS"]},"rawMarkdownBody":"\r\n## 현재 상황\r\n\r\n현재 회사에서 만들고 있는 서비스에서 이메일을 통한 인증 방식을 사용하는 부분이 두 군데 있다.\r\n회원가입 시 사용한 이메일을 인증하는 부분과 비밀번호를 찾을 때 전송된 메일을 통해서 들어온 경우에만 비밀번호 재설정을 할 수 있게 하는 부분이다.\r\n\r\n지금은 단순히 이메일 내 버튼에 이동시킬 페이지 주소를 넣어놓고 클릭 시 해당 페이지로 이동하도록 되어있다.\r\n회원의 verify 정보도 업데이트 해야하고, 비밀번호 찾기에서는 회원 정보도 있어야 하는데..  \r\n이메일을 통한 인증을 처음 구현하다보니 잘 모르긴 몰라도 이렇게만 해서는 인증이 되는건 아닌 것 같아서 (당연)  \r\n'어떻게 구현해야하는걸까?' 를 찾아보고 알게 된 내용을 정리해보려고 한다.\r\n\r\n## 구현 고민\r\n\r\n잘 모르는 부분과 이해가 안갔던 부분을 처음부터 좀 되짚어봤다.\r\n\r\n### 인증 방식\r\n\r\n일단 인증 방식. 보통 어떤 식으로 이메일 인증을 구현하는지를 먼저 찾아봤는데 크게 두 가지 방식이 있는 것 같다.\r\n\r\n```\r\n1. 메일 내용에 인증코드를 적어주고, 해당 인증코드로 인증하도록 하는 방식\r\n2. 메일에 링크만 전달하여 해당 링크로 인증하는 방식\r\n```\r\n\r\n1번의 경우 랜덤값을 생성한 후 DB에 저장하고 메일에도 전송을 한 다음, 특정 페이지로 이동시켰을 때 해당 랜덤값을 입력해서 일치하는지 확인하여 인증하는 방식이고  \r\n2번의 경우는 메일에 있는 링크를 통해 접속했을 때 인증이 되는 방식이다.\r\n\r\n우리의 서비스 기획에는 인증코드 방식이 아니라 메일에 있는 버튼 클릭하면 인증이 되어 다음 플로우를 진행하는 방식으로 되어있다.\r\n\r\n### 보안상 괜찮은지?\r\n\r\n비밀번호 찾기를 하게 되면 링크를 통해 이동한 페이지에서 어떤 사용자의 비밀번호를 바꾸는 것인지, 사용자에 대한 정보를 알 수 있어야 한다. 버튼에 연결한 주소의 쿼리스트링으로 사용자의 이메일을 그대로 넘겨도 되겠지만 이게 보안상 괜찮은 것인지에 대한 걱정이 있었다.  \r\n이메일을 그대로 넘기게 되면 어떤 사람의 이메일을 알았을 때, 비밀번호 변경 페이지의 주소와 합쳐서 url만 입력하면 누구든지 비밀번호 변경 페이지에 들어갈 수 있기 때문에 좋지 않을 것 같았다.\r\n\r\n찾아보니 `토큰`을 만들어 쿼리스트링으로 넘긴 후에 사용하는 것 같아서, 이 단계까지 찾아봤을 때에는 클라이언트에서 `JWT`를 발급받은 후 메일에 넣어주도록 하게끔 만들 생각을 했다.\r\n\r\n### 버튼은 하나인데 동작은 두 개..?\r\n\r\n이 부분이 제일 이해가 안되서 계속 찾아봤던 부분인 것 같다.\r\n\r\n회원 가입 이후의 이메일 인증 과정에서는 메일의 버튼을 클릭했을 때 `이 사용자는 인증이 되어 로그인을 할 수 있다!`를 판단할 수 있도록 사용자의 인증 상태에 대한 값을 변경시켜줘야한다.\r\n그러면 생각을 해봤을 때 백엔드의 API를 호출해서 사용자 상태를 바꿔주면 될 것 같은데 버튼 클릭했을 때 페이지 자체는 로그인 페이지로 이동이 되어야 한다.  \r\n그래서 이메일 템플릿에서 스크립트도 사용할 수 있나 했는데 그건 안된다고 한다.\r\n\r\n그러면 도대체 어떻게 해야하는거지????  \r\n계속 찾아봐도 그냥 토큰 만들어서 인증하는 것만 나오고 내가 궁금한건 `도대체 어떻게 원하는 페이지로 이동시키는건데!!` 였다.\r\n\r\n검색어를 좀 바꿔서 `이메일 인증 후 리다이렉트` 로 검색을 해서 찾아보다가 마침내 원하는 답을 찾았다!!\r\n\r\n## 해결 방법\r\n\r\n찾아낸 해결 방법은 `response.redirect`를 사용하는 것이다.  \r\n[이 블로그](https://yunb2.tistory.com/4)의 인증 확인 부분에서 `response.sendRedirect`를 하는 부분이 있는데,\r\n우리는 nodejs를 사용하고 있기 때문에 좀 다를거라 생각했고 찾아보니 sendRedirect가 아니라 그냥 redirect를 사용하면 되는 것 같았다. 근데 이제 redirect 뿐만 아니라 forward라는 것도 같이 나와서 좀 찾아봤다.\r\n\r\n그리고 지금 이 글을 쓰는 시점에서 (계속 찾아보면서 쓰고 있음)\r\nNestJS에서 애초에 Controller 쪽에 `@Redirect`를 제공하고 있다...ㅎㅎ..  \r\n역시 공식문서 정말 중요하다!ㅎㅎ\r\n\r\n## 마무리 ?\r\n\r\n쓰다보니 인증 과정 구현하는걸 시리즈로 써도 좋을 것 같아서 이번 글은 내가 뭘 모르고 헷갈렸던건지, 어떻게 찾아봤는지, 결론은 어떻게 냈는지에 대해서만 쓰려고 한다.\r\n\r\n그래서 결론은!\r\n\r\n1. 회원가입 인증 메일\r\n   버튼에는 백엔드 API의 endpoint를 연결해두고 버튼을 클릭해 API가 호출되면 사용자의 인증 상태 값 업데이트하고 원하는 페이지로 redirect 시키기\r\n\r\n2. 비밀번호 찾기\r\n   버튼에 연결시킬 url의 쿼리스트링으로 사용자 정보를 담은 JWT가 설정되도록 해서 이메일을 보내고, 해당 페이지에서 JWT 값으로 사용자 정보를 가져와 사용할 수 있도록 하기\r\n\r\n이렇게 생각했다.  \r\n근데 회원가입 인증 메일, 비밀번호 찾기 둘다 30분 제한 시간 내에 실행되었을 때만 할 예정이라서 JWT에는 expiresIn을 설정하면 되지만 회원가입 메일은 어떻게 할지 좀 더 생각을 해봐야할 것 같다.  \r\n이것도 마찬가지로 메일 보낼 때 expiresIn 설정되어 있는 JWT를 보내고 받아서 처리할지..  \r\n이렇게 하면 될 것 같긴 함..\r\n\r\nTO BE CONTINUE...\r\n"},{"excerpt":"Map은 키-값 쌍으로 이루어진다. 키를 갖는다는 것에서 객체와 유사하지만 다른 점이 있다. Object Map 이터러블하지 않음 이터러블함 요소 개수 확인하는 프로퍼티 없음 size 프로퍼티로 요소 개수 확인 가능 string이나 Symbol만 키로 올 수 있음 모든 값이 키가 될 수 있음 순서가 보장되지 않음 삽입된 순서를 기억함 주요 메서드와 프로퍼…","fields":{"slug":"/230622-Map/"},"frontmatter":{"date":"June 22, 2023","title":"Map (ES6)","tags":["javascript","ES6"]},"rawMarkdownBody":"\r\nMap은 키-값 쌍으로 이루어진다. 키를 갖는다는 것에서 객체와 유사하지만 다른 점이 있다.\r\n\r\n| Object                              | Map                                 |\r\n| ----------------------------------- | ----------------------------------- |\r\n| 이터러블하지 않음                   | 이터러블함                          |\r\n| 요소 개수 확인하는 프로퍼티 없음    | size 프로퍼티로 요소 개수 확인 가능 |\r\n| string이나 Symbol만 키로 올 수 있음 | 모든 값이 키가 될 수 있음           |\r\n| 순서가 보장되지 않음                | 삽입된 순서를 기억함                |\r\n\r\n## 주요 메서드와 프로퍼티\r\n\r\nMap에서 사용되는 메서드와 프로퍼티들이다.\r\n\r\n- new Map() : Map 객체 생성\r\n- map.set(key, value) : key를 이용해 value 저장\r\n- map.get(key) : key에 해당하는 value 반환. key가 없으면 undefined 반환\r\n- map.has(key) : key 존재 여부 확인 (true/false 반환)\r\n- map.delete(key) : key에 해당하는 값 삭제\r\n- map.clear() : Map 안의 모든 요소 제거\r\n- map.size : 요소 개수 반환\r\n\r\n## Map 객체 생성\r\n\r\nMap 객체는 Map 생성자 함수로 생성할 수 있다.\r\n`이터러블`을 인수로 전달받아 Map 객체를 생성하고, 인수를 전달하지 않으면 빈 Map 객체가 생성된다.\r\n전달하는 이터러블은 키-값 쌍으로 이루어진 요소로 구성되어야 한다.\r\n\r\n```javascript\r\nconst map1 = new Map(); // 빈 Map 객체 생성\r\nconst map2 = new Map([[\"key1\", \"value1\", \"key2\", \"value2\"]]);\r\n\r\nconst map3 = new Map([1, 2]); // TypeError\r\n```\r\n\r\nMap은 중복된 키를 가질 수 없기 때문에 이미 생성한 키를 넣으면 덮어씌워진다.\r\n\r\n```javascript\r\nconst map = new Map([\r\n  [1, 2],\r\n  [1, 5],\r\n]);\r\nconsole.log(map); // Map(1) {1 => 5}\r\n```\r\n\r\n## 요소 추가\r\n\r\nMap.prototype.set 메서드를 사용해서 요소를 추가할 수 있다.  \r\nset 메서드를 사용하면 새로운 요소가 추가된 Map 객체를 반환하기 때문에 연속적으로 set 메서드를 호출할 수 있다.\r\n\r\n```javascript\r\nconst map = new Map();\r\n\r\nmap.set(\"key1\", \"value1\");\r\nconsole.log(map); // Map(1) {\"key1\" => \"value1\"}\r\n\r\nmap.set(\"key2\", \"value2\").set(\"key3\", \"value3\");\r\nconsole.log(map); // Map(1) {\"key1\" => \"value1\", \"key2\" => \"value2\", \"key3\" => \"value3\"}\r\n```\r\n\r\n모든 값이 key가 될 수 있는 Map의 특징에 의해 객체 또한 key가 될 수 있다.\r\n\r\n```javascript\r\nconst map = new Map();\r\n\r\nconst lee = { name: \"Lee\" };\r\nconst kim = { name: \"Kim\" };\r\n\r\nmap.set(kim, \"developer\").set(lee, \"singer\");\r\nconsole.log(map); // Map(1) { {name: \"Kim\"} => \"developer\", {name: \"Lee\"} => \"singer\" }\r\n```\r\n\r\n## 요소 가져오기\r\n\r\nMap.prototype.get 메서드로 key에 해당하는 value를 가져올 수 있다. 해당하는 key가 없는 경우에는 undefined가 반환된다.\r\n\r\n```javascript\r\nconst map = new Map();\r\n\r\nconst lee = { name: \"Lee\" };\r\nconst kim = { name: \"Kim\" };\r\n\r\nmap.set(kim, \"developer\").set(lee, \"singer\");\r\n\r\nconsole.log(map.get(lee)); // developer\r\nconsole.log(map.get(\"x\")); // undefined\r\n```\r\n\r\nobject는 키를 문자형으로 변환을 하는데, Map은 변환시키지 않고 그대로 유지한다.\r\n그렇기 때문에 다음과 같은 경우 반환되는 값이 달라진다.\r\n\r\n```javascript\r\nconst map = new Map([\r\n  [1, 5],\r\n  [\"1\", 10],\r\n]);\r\nconsole.log(map.get(1)); // 5\r\nconsole.log(map.get(\"1\")); // 10\r\n```\r\n\r\n## 요소 존재여부 확인\r\n\r\nMap.prototype.has 메서드로 존재여부를 확인할 수 있다. true/false가 반환된다.\r\n\r\n```javascript\r\nconst map = new Map();\r\n\r\nconst lee = { name: \"Lee\" };\r\nconst kim = { name: \"Kim\" };\r\n\r\nmap.set(kim, \"developer\").set(lee, \"singer\");\r\n\r\nconsole.log(map.has(lee)); // true\r\nconsole.log(map.has(\"x\")); // false\r\n```\r\n\r\n## 요소 삭제\r\n\r\nMap.prototype.delete로 요소를 삭제할 수 있다. 삭제 성공 여부(true/false)가 반환된다.\r\ntrue/false가 반환되기 때문에 set과 다르게 연속적으로 호출할 수 없다.\r\n\r\n```javascript\r\nconst map = new Map([\r\n  [1, 10],\r\n  [2, 20],\r\n]);\r\nmap.delete(1);\r\nconsole.log(map); // Map(1) {2 => 20}\r\n```\r\n\r\n존재하지 않는 key로 삭제하려고 하면 에러는 발생하지 않고 그냥 무시된다.\r\n\r\n## 모든 요소 삭제\r\n\r\nMap.prototype.clear 메서드로 모든 요소를 삭제할 수 있다. 언제나 undefined가 반환된다.\r\n\r\n```javascript\r\nconst map = new Map();\r\n\r\nconst lee = { name: \"Lee\" };\r\nconst kim = { name: \"Kim\" };\r\n\r\nmap.set(kim, \"developer\").set(lee, \"singer\");\r\nmap.clear();\r\nconsole.log(map);  Map(0) {}\r\n```\r\n\r\n## 요소 개수 확인\r\n\r\nMap.prototype.size 프로퍼티를 사용하면 쉽게 요소의 개수를 가져올 수 있다.  \r\nObject의 경우에는 크기를 알려면 Object.keys(obj).length 처럼 key의 배열의 길이로 알아내는 방식을 사용해야하는데,\r\nMap에는 기본적으로 size라는 프로퍼티가 있어 요소의 개수를 바로 알아낼 수 있다.\r\n\r\n```javascript\r\nconst { size } = new Map([\r\n  [\"key1\", \"value1\"],\r\n  [\"key2\", \"value2\"],\r\n]);\r\nconsole.log(size); // 2\r\n```\r\n\r\n## 요소 순회\r\n\r\nMap.prototype.forEach 메서드를 사용해 요소를 순회할 수 있다. (Map이 따로 forEach 메서드를 갖는건 처음 알았다.)\r\n순회되는 순서는 삽입 순서에 따라 순회가 되어 먼저 삽입된 key부터 순회한다.\r\n콜백 함수와 콜백 함수를 실행하고 있을 때 this로 사용하는 값(optional)을 인자로 받는다.\r\n\r\n```javascript\r\nconst map = new Map([\r\n  [1, 10],\r\n  [2, 20],\r\n  [3, 30],\r\n]);\r\nmap.forEach((value, key, map) => {\r\n  console.log(value, key, map);\r\n}, thisArg);\r\n```\r\n\r\n### 이터러블\r\n\r\nObject는 순회가 되지 않기 때문에 Object.keys(obj)로 for..of 실행해서 객체에 직접 접근해서 한다던가, entries를 사용한다. (Object.prototype.entries는 ES2017에 추가됨)  \r\n하지만 Map 객체는 Map 객체 자체가 이터러블하기 때문에 for...of 문을 통한 순회가 가능하다.  \r\n또한 스프레드 문법과 배열 디스트럭처링 할당의 대상이 될 수도 있다.\r\n\r\n```javascript\r\nconst obj1 = {\r\n  a: \"aa\",\r\n  b: \"bb\",\r\n};\r\n\r\n// object는 이터러블하지 않기 때문에 entries 메서드를 사용함\r\nfor (const key of Object.keys(obj1)) {\r\n  console.log(key, obj1[key]);\r\n}\r\n\r\nconst map = new Map([\r\n  [\"a\", \"aa\"],\r\n  [\"b\", \"bb\"],\r\n]);\r\n// map 자체가 이터러블함\r\nfor (const [key, value] of map) {\r\n  console.log(key, value);\r\n}\r\n\r\nconsole.log([...map]); // [[\"a\", \"aa\"],[\"b\", \"bb\"]]\r\n```\r\n\r\nMap.prototype.keys, Map.prototype.values, Map.prototype.entries 메서드도 제공하고 있다.\r\n\r\n## Map to Object\r\n\r\n`Object.fromEntries()` 를 사용하여 Map 객체를 Object로 변환시킬 수 있다.\r\n\r\n```javascript\r\nconst map = new Map([\r\n  [\"one\", 1],\r\n  [\"two\", 2],\r\n]);\r\n\r\nconst obj = Object.fromEntries(map);\r\nconsole.log(obj); // {one: 1, two: 2}\r\n```\r\n\r\n## 언제 활용해야할까?\r\n\r\n사실 Map 객체를 잘 사용하고 있진 않다. 거의 Object를 사용하고 있는데, 이번 내용을 찾아보면서 언제 Map을 쓰면 되는걸까 찾아봤다.\r\n\r\n근데 대부분 그냥 Map의 특징과 엮어서 설명하고 있는 것 같다.  \r\n순서에 따라 반복문을 실행하고 싶을 때, key로 string, symbol외의 값을 사용하고 싶을 때 등의 상황에서 쓰면 된다.\r\n\r\n성능적으로는 MDN에 따르면 키-값 쌍의 빈번한 추가 및 제거와 관련된 상황에서는 Map이 성능이 좀 더 좋다고 한다.\r\n\r\n앞으로 코드 작업할 때 Map을 활용할 수 있는 상황이라면 Object 대신에 Map을 활용하는 쪽으로 작성해봐야겠다.\r\n맨날 익숙하게 쓰는 것만 쓰는 게 아쉬움..\r\n\r\n참고\r\n\r\n- https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Map\r\n"},{"excerpt":"For...of for...of 문은 반복가능한 객체 (Array, Map, Set, String, TypedArray, arguments 객체 등을 포함)에 대해서 반복한다. 위와 같이 반복의 대상은 iterable해야 한다. iterable 하다는 것은 Symbol.iterator 속성을 가지고 있다는 것이다. for...in 과의 차이점이 for..…","fields":{"slug":"/230616-for...of 반복문/"},"frontmatter":{"date":"June 16, 2023","title":"for...of 반복문 (ES6)","tags":["javascript","ES6"]},"rawMarkdownBody":"\r\n## For...of\r\n\r\nfor...of 문은 반복가능한 객체 (Array, Map, Set, String, TypedArray, arguments 객체 등을 포함)에 대해서 반복한다.\r\n\r\n```javascript\r\nfor (variable of iterable) {\r\n  statement;\r\n}\r\n```\r\n\r\n위와 같이 반복의 대상은 iterable해야 한다. iterable 하다는 것은 [Symbol.iterator] 속성을 가지고 있다는 것이다.\r\n\r\nfor...in 과의 차이점이 for...in은 객체의 모든 열거 가능한 속성에 대해 반복하지만,  \r\nfor...of는 [Symbol.iterator] 속성을 가지는 것만 반복할 수 있다.\r\n\r\nfor...of에서 index와 value를 같이 받아오고 싶은 경우에는 다음과 같이 작성하면 된다.\r\n\r\n```javascript\r\nfor (const [idx, val] of Iterable.entries()) {\r\n  console.log(idx, val);\r\n}\r\n```\r\n\r\n### 성능 비교 ?\r\n\r\n반복문에 대한 내용을 보다보면 꼭 성능에 대한 이야기가 나온다.\r\n가장 기본적인 for문 부터 forEach, for...in, while 등 반복문을 실행할 수 있는 것들이 많기 때문인데,\r\n성능 비교해놓은 것을 보면 for문이 다른 반복문에 비해 빠른 편(while도 비슷)이고 for...in이 제일 느린 편이다.\r\n\r\nfor문이 제일 빠르니까 for문 써야지! 라기보단 상황에 맞춰 사용하는 것이 중요한 것 같다.\r\n예를 들어 continue, break를 써야한다면 forEach는 안쓴다던가..\r\n어떤 내용을 작성하는가에 따라 적절히 활요하면 될 것 같다.  \r\n근데 보통 for...in은 성능상 떨어지는 것 같아서 많이들 안쓰는 것 같긴 하다. 실제로 나도 별로 안쓰긴 하는 듯..?  \r\n나는 for...of나 for문을 많이 쓰는 것 같다.\r\n"},{"excerpt":"스프레드 연산자 (...) 은 반복 가능한(iterable) 객체에 적용할 수 있는 문법이다. 배열, 문자열 등의 요소 하나하나를 spread(전개) 시켜주는 문법이다. 스프레드 연산자를 사용했을 때의 결과물은 값이 아닌 값들의 목록 이라고 할 수 있다. 그렇기 때문에 쉼표로 구분한 값의 목록을 사용하는 문맥에서 사용할 수 있다. 함수 호출문의 인수 목록…","fields":{"slug":"/230615-스프레드 연산자/"},"frontmatter":{"date":"June 15, 2023","title":"스프레드 연산자 (ES6)","tags":["javascript","ES6"]},"rawMarkdownBody":"\r\n스프레드 연산자 (...) 은 반복 가능한(iterable) 객체에 적용할 수 있는 문법이다. 배열, 문자열 등의 요소 하나하나를 spread(전개) 시켜주는 문법이다.\r\n\r\n스프레드 연산자를 사용했을 때의 결과물은 값이 아닌 값들의 목록 이라고 할 수 있다. 그렇기 때문에 쉼표로 구분한 값의 목록을 사용하는 문맥에서 사용할 수 있다.\r\n\r\n## 함수 호출문의 인수 목록에서 사용\r\n\r\n```javascript\r\nconst numbers = [23, 55, 21, 87, 56];\r\nlet maxValue = Math.max(...numbers);\r\n```\r\n\r\nMath.max 메서드는 매개변수 개수를 확정할 수 없는 가변 인자 함수다. 인수로 전달받은 여러 개의 숫자 중에서 최대값을 반환해준다.  \r\nMath.max에 숫자가 아닌 배열을 인수로 전달하면 NaN을 반환한다.\r\n\r\n스프레드 연산자가 없었을 때에는\r\n\r\n```javascript\r\nconst arr = [1, 2, 3];\r\nconst max = Math.max.apply(null, arr);\r\n```\r\n\r\n이렇게 해야 사용이 가능했는데, 스프레드 연산자가 생기면서 훨씬 간결하게 작성할 수 있게 되었다.\r\n\r\n## 배열 리터럴 내부에서 사용\r\n\r\nES5에서 2개의 배열을 하나로 합칠 때 concat 매서드를 사용해야 했다.  \r\n이를 ES6의 스프레드 연산자를 사용하면 간단하게 만들 수 있다.\r\n\r\n```javascript\r\nconst arr1 = [\"a\", \"b\", \"c\"];\r\nconst arr2 = [\"d\", \"e\", \"f\"];\r\n\r\n// ES5\r\nconst result1 = arr1.concat(arr2); // ['a', 'b', 'c', 'd', 'e', 'f']\r\n\r\n// ES6\r\nconst result2 = [...arr1, ...arr2]; // ['a', 'b', 'c', 'd', 'e', 'f']\r\n```\r\n\r\n배열 중간에 다른 배열의 요소를 추가할 때에도 쉽게 가능하다.\r\n\r\n```javascript\r\nconst arr1 = [1, 4];\r\nconst arr2 = [2, 3];\r\n\r\narr1.splice(1, 0, ...arr2);\r\n```\r\n\r\n배열 복사 할 때에도 사용 가능하다.\r\n\r\n```javascript\r\nconst origin = [\"a\", \"b\", \"c\"];\r\nconst copy = [...origin];\r\n\r\nconsole.log(copy); // [\"a\", \"b\", \"c\"]\r\nconsole.log(origin === copy); // false\r\n```\r\n\r\n## 객체 리터럴의 프로퍼티 목록\r\n\r\n객체도 iterable 하기 때문에 스프레드 연산자를 사용할 수 있다.\r\n\r\n```javascript\r\nconst obj1 = {\r\n  a: 1,\r\n};\r\nconst obj2 = { ...obj1 }; // { a: 1 }\r\n\r\nconsole.log(obj1 === obj2); // false\r\n\r\nconst obj3 = {\r\n  x: 1,\r\n  y: 2,\r\n};\r\nconst obj4 = {\r\n  a: 3,\r\n  b: 4,\r\n};\r\nconst merged = { ...obj3, obj4 };\r\nconsole.log(merged); // { x: 1, y: 2, a: 3, b: 4}\r\n```\r\n\r\n위처럼 합칠 때만이 아니라 특정 프로퍼티의 변경 및 추가할 때도 사용할 수 있다.\r\n\r\n```javascript\r\nconst obj3 = {\r\n  x: 1,\r\n  y: 2,\r\n};\r\nconst obj4 = {\r\n  a: 3,\r\n  b: 4,\r\n};\r\nconst changed = { ...obj3, x: 3 };\r\nconsole.log(changed); // { x: 3, y: 2}\r\n\r\nconst added = { ...obj4, c: 10 };\r\nconsole.log(added); // { a: 3, b: 4, c: 10}\r\n```\r\n\r\n객체와 배열 모두 복사했을 때 원본과 비교하면 false의 값이 나왔다.\r\n원본, 복사본은 다른 주소값을 갖기 때문에 원본을 변경해도 복사본에 영향이 없는데,  \r\n객체의 경우 객체 내부에 중첩된 객체를 갖고 있다면 해당 객체는 원본이 변경되면 복사본에서도 변경이 된다.\r\n\r\n```javascript\r\nconst origin = { name: { first: \"yujuck\", last: \"kim\" }, age: 1 };\r\nconst copy = { ...origin };\r\n\r\nconsole.log(origin === copy); // false\r\n\r\norigin.name.last = \"lee\";\r\norigin.age = 10;\r\n\r\nconsole.log(origin); // { name: {first: \"yujuck\", last: \"lee\"}, age: 10 };\r\nconsole.log(copy); // { name: {first: \"yujuck\", last: \"lee\"}, age: 1 };\r\n```\r\n"},{"excerpt":"ES6 이전의 함수 ES6 이전까지의 자바스크립트 함수는 로서 호출할 수도 있고, new 연산자와 함께 호출하여 인스턴스를 생성할 수 있는 로서 호출할 수도 있으며, 객체에 바인딩되어 할 수도 있다. 이러한 특징은 편리한 것 같지만 사용 목적에 따라 명확히 구분되지 않아 실수를 유발할 수도 있고 성능면에서도 문제가 있다. ES6 이전의 모든 함수는 일반 …","fields":{"slug":"/230614-화살표 함수/"},"frontmatter":{"date":"June 14, 2023","title":"화살표 함수 (ES6)","tags":["javascript","ES6"]},"rawMarkdownBody":"\r\n## ES6 이전의 함수\r\n\r\nES6 이전까지의 자바스크립트 함수는 `일반적인 함수`로서 호출할 수도 있고, new 연산자와 함께 호출하여 인스턴스를 생성할 수 있는 `생성자 함수`로서 호출할 수도 있으며, 객체에 바인딩되어 `메서드로서 호출`할 수도 있다. 이러한 특징은 편리한 것 같지만 사용 목적에 따라 명확히 구분되지 않아 실수를 유발할 수도 있고 성능면에서도 문제가 있다.\r\n\r\n```javascript\r\nvar func = function () {\r\n  return 1;\r\n};\r\n\r\n// 일반적인 함수로서 호출\r\nfunc(); // 1\r\n\r\n// 생성자 함수로서 호출\r\nnew func(); // func {}\r\n\r\n// 메서드로서 호출\r\nvar obj = { myFunction: func };\r\nobj.myFunction();\r\n```\r\n\r\nES6 이전의 모든 함수는 일반 함수로서 호출할 수 있으면서 생성자 함수로서 호출할 수 있다. 이것은 callable이면서 constructor라는걸 의미한다. 객체에 바인딩된 함수(메서드) 또한 문법상으로는 객체에 바인딩된 함수를 생성자 함수로 호출할 수도 있다.\r\n\r\n```javascript\r\nvar obj = {\r\n  x: 10,\r\n  f: function () {\r\n    return this.x;\r\n  },\r\n};\r\n\r\n// f에 바인딩된 함수를 메서드로서 호출\r\nconsole.log(obj.f()); // 10\r\n\r\nvar bar = obj.f;\r\n// f에 바인딩된 함수를 일반 함수로서 호출\r\nconsole.log(bar()); // undefined\r\n\r\n// f에 바인딩된 함수를 생성자 함수로서 호출\r\nconsole.log(new obj.f()); // f {}\r\n```\r\n\r\n이렇게 되면 성능에서도 문제가 있는 게, 객체에 바인딩된 함수가 constructor라는 것은\r\n객체에 바인딩된 함수가 prototype 프로퍼티를 가지며, 프로토타입 객체도 생성한다는 것을 의미하기 때문이다.\r\n\r\n이렇게 사용 목적에 따라 명확한 구분이 없어 생기는 문제를 해결하기 위해 ES6에서는 함수를 사용 목적에 따라 구분한다.\r\n\r\n## 화살표 함수 (Arrow Function)\r\n\r\nES6에서 처음 도입된 화살표 함수의 사용법은 다음과 같다.\r\n\r\n```javascript\r\nconst x = (x, y) => x * y;\r\n```\r\n\r\n### 일반 함수와의 차이\r\n\r\n1. 인스턴스를 생성할 수 없는 non-constructor\r\n\r\n화살표 함수는 인스턴스를 생성할 수 없으므로 prototype 프로퍼티가 없고 프로토타입도 생성하지 않는다.\r\n\r\n```javascript\r\nconst func = () => {};\r\nnew func(); // TypeError: func is not a constructor\r\n```\r\n\r\n2. 중복된 매개변수 이름을 선언할 수 없음\r\n\r\n일반 함수는 중복된 매개변수 이름을 선언해도 에러가 발생하지 않는다. (처음 알았다. 이렇게 써본 적이 없어서..)\r\nstrict mode에서는 에러가 발생한다.\r\n\r\n```javascript\r\nfunction normal(a, a) {\r\n  return a + a;\r\n}\r\nconsole.log(normal(1, 2)); // 3\r\n```\r\n\r\n화살표 함수는 strict mode가 아니여도 중복된 매개변수 이름을 선언하면 에러가 발생한다.\r\n\r\n```javascript\r\nconst arrow = (a, a) => {\r\n  return a + a;\r\n}; // SyntaxError\r\n```\r\n\r\n3. 함수 자체의 this, arguments, super, new.target 바인딩을 갖지 않음\r\n\r\n화살표 함수 내부에서 this, arguments, super, new.target을 참조하면 스코프 체인을 통해 상위 스코프의 것을 참조한다. 화살표 함수가 콜백 함수 내부에서 this가 전역 객체를 가리키는 문제를 해결하기 위한 대안으로 유용한 이유이다.\r\n\r\n만약에 화살표 함수가 중첩되어 있다면 상위 화살표 함수에도 this, arguments 등의 바인딩이 없으므로 스코프 체인 상에서 가장 가까운 함수 중 화살표 함수가 아닌 함수의 것을 참조한다.\r\n\r\n### this\r\n\r\n화살표 함수와 일반 함수를 구분했을 때 가장 큰 차이점은 this다.  \r\n화살표 함수는 함수 자체의 this 바인딩을 갖지 않는다. 그렇기 때문에 화살표 함수 내부에서 this를 참조하면 상위 스코프의 this를 그대로 참조한다.\r\n이를 `lexical this` 라고 하고, 화살표 함수의 this가 함수가 정의된 위치에 의해 결정된다는 것을 의미한다.\r\n\r\nthis가 상위 스코프의 this를 참조하기 때문에 메서드를 화살표 함수로 정의하는 것은 좋지 않다.\r\n\r\n```javascript\r\nconst person = {\r\n  name: \"yujuck\",\r\n  func: () => console.log(`hi ${this.name}`),\r\n};\r\n\r\nperson.func(); // hi\r\n```\r\n\r\n'hi' 만 출력되는 이유는 func에서 참조하는 this는 전역 객체를 가리키기 때문이다.\r\n\r\n원하는대로 객체의 name 프로퍼티를 가져오려면 다음과 같이 ES6 메서드 축약 표현으로 정의한 ES6 메서드를 사용하는 것이 좋다.\r\n\r\n```javascript\r\nconst person = {\r\n  name: \"yujuck\",\r\n  func() {\r\n    console.log(`hi ${this.name}`);\r\n  },\r\n};\r\n\r\nperson.func(); // hi\r\n```\r\n\r\n### super, arguments\r\n\r\nsuper와 arguments도 this와 마찬가지로 화상표 함수 내부에서 super, arguments를 참조하면 상위 스코프의 super, arguments를 참조한다.\r\n\r\narguments의 경우 화살표 함수에서는 arguments 객체를 사용할 수 없다.  \r\n상위 스코프의 arguments 객체를 참조할 수는 있지만 화살표 함수에게 전달된 인수 목록을 확인할 수 없고 상위 함수에게 전달된 인수 목록을 참조하기 때문이다.\r\n따라서 화살표 함수로 가변 인자 함수를 구현해야 할 경우, Rest 파라미터를 사용해야한다.\r\n"},{"excerpt":"지금은 기본 중의 기본이 되어있는 ES6인데 글을 쓰는 이유는..? ES6 이후에 나온 내용들도 한번 쭉 보고 싶어서 시리즈로 만들기 위해 적어보려고 한다! ECMAScript? ES? Ecma International이 기술 규격에 따라 정의하고 있는 표준화된 스크립트 프로그래밍 언어 Javascript는 Netscape 회사의 Brendan Eich …","fields":{"slug":"/230613-ES6 문법 1탄/"},"frontmatter":{"date":"June 13, 2023","title":"ES6(ECMAScript 6)와 let, const 키워드","tags":["javascript","ES6"]},"rawMarkdownBody":"\r\n지금은 기본 중의 기본이 되어있는 ES6인데 글을 쓰는 이유는..?  \r\nES6 이후에 나온 내용들도 한번 쭉 보고 싶어서 시리즈로 만들기 위해 적어보려고 한다!\r\n\r\n## ECMAScript? ES?\r\n\r\n> Ecma International이 `ECMA-262`기술 규격에 따라 정의하고 있는 표준화된 스크립트 프로그래밍 언어\r\n\r\nJavascript는 Netscape 회사의 Brendan Eich 라는 사람에 의해 최초로 개발되었다. 그 후 Javascript의 성공에 자극을 받은 마이크로소프트는 Jscript 라는 언어를 개발하고 IE에 지원되기 시작했다.  \r\n두 스크립트가 서로 호환되지 못하는 경우가 생기게 되면서 표준화가 요구되었고, ECMA-262의 이름으로 1996년 11월부터 시작됐다.\r\n\r\n`ES`는 `ECMAScript의 약자`다. 헷갈릴 수 있는 게 `ES6`는 ES016이 아니라 `ES2015`와 동일하다.\r\n현재는 ES6보다 더 많은 버전이 나와있는데도 최신 버전의 내용보다 ES6의 내용을 중요하게 보는 데에는 이유가 있다.\r\n\r\n먼저, ES6에 추가된 개념들이 ES6 이하 버전에서 문제가 되었던 부분들이 해결되고 많은 기능이 추가되어 현재까지도 중요한 개념들이기 때문이다. 그리고 구버전의 웹 브라우저나 레거시 코드와의 호환성 문제가 있어 대부분의 기업들이 ES6까지를 호환성의 최대치로 보고 있다고 한다.\r\n\r\n### let, const\r\n\r\n이제는 너무 기본적인 `let` 과 `const`.\r\n\r\n블록 스코프의 변수 선언을 할 수 있게 되었다. var와의 가장 큰 차이점이 바로 함수 스코프가 아닌 블록 스코프 변수 선언이라는 것이다.\r\n\r\n`let`과 `const`의 차이점은 const는 한번 초기화하면 다른 값을 정의할 수 없지만 let은 계속 값을 변경할 수 있다. 주의할 점은 const여도 객체나 배열의 요소의 변경을 막진 않는 다는 것이다.\r\n\r\n호이스팅에 대한 얘기도 무조건 나온다.\r\n\r\nvar 키워드와 달리 let과 const는 변수 호이스팅이 발생하지 않는 것처럼 동작한다.\r\n\r\n```javascript\r\nconsole.log(x); // ReferenceError\r\nlet x;\r\n```\r\n\r\nvar 키워드로 선언했다면 위의 상황에서 ReferenceError가 아닌 undefined가 출력되었을 것이다.  \r\n`var` 키워드 변수는 런타임 이전에 선언 단계와 초기화 단계가 `한번에 진행`되는데,  \r\n`let` 키워드 변수는 선언 단계와 초기화 단계가 `분리되어 진행`된다.  \r\n즉, 런타임 이전에 선언 단계가 먼저 실행되지만 `초기화 단계는 변수 선언문에 도달했을 때 실행`된다.\r\n\r\n초기화 단계가 실행되기 이전에 변수에 접근하려고 하면 참조 에러(ReferenceError)가 발생한다.  \r\nlet 키워드 변수는 스코프 시작 지점부터 초기화 단계가 실행되는 변수 선언문까지는 변수를 참조할 수 없는데,\r\n이 구간을 `일시적 사각지대`(Temporal Dead Zone: TDZ) 라고 한다.\r\n\r\n위의 특성 때문에 변수 호이스팅이 발생하지 않는 것처럼 보이지만 그렇지는 않다.\r\n\r\n```javascript\r\nlet x = 1; // 전역변수\r\n{\r\n  console.log(x); // ReferenceError\r\n  let x = 2; // 지역변수\r\n}\r\n```\r\n\r\n변수 호이스팅이 발생하지 않는다면 위 예제는 전역 변수 x의 값을 출력해야하는데,\r\n그렇지 않고 ReferenceError가 발생한다.  \r\n-> 호이스팅이 발생했기 때문에 지역 변수 x의 존재를 알고 있지만 값이 초기화 되어있지 않아서 ReferenceError가 발생\r\n\r\n자바스크립트는 ES6에서 도입된 let, const를 포함해서 모든 선언(var, let ,const, function, class 등)을 호이스팅 한다.  \r\n단, ES6에서 도입된 let, const class를 사용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작한다.\r\n\r\n참고 (ES6 관련 글 모두)\r\n\r\n- [ECMA스크립트](https://ko.wikipedia.org/wiki/ECMA%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8)\r\n- [ES6](https://velog.io/@krungy/ES6)\r\n- [Javascript ES6](https://www.w3schools.com/js/js_es6.asp)\r\n- [ECMAScript](https://www.zerocho.com/category/ECMAScript)\r\n- 모던 자바스크립트 Deep Dive\r\n"},{"excerpt":"서비스를 개발하다보면 주기적으로 처리되어야 하는 작업들이 있다. 우리 서비스에서는 테스트로 넣었던 주문들의 상태를 취소 상태로 변경하는 것을 주기적으로 처리하고 있고,\nLet's Encrypt SSL 인증서를 3개월마다 자동 갱신할 수 있도록 처리해놓기도 했다. 현재 개발 중인 서비스에서는 5분마다 결제 완료된 주문 정보를 찾아 주문 데이터를 생성할 수 …","fields":{"slug":"/230612-crontab 설정을 해보자/"},"frontmatter":{"date":"June 12, 2023","title":"crontab 설정을 해보자","tags":["crontab","linux","ubuntu"]},"rawMarkdownBody":"\r\n서비스를 개발하다보면 주기적으로 처리되어야 하는 작업들이 있다.  \r\n우리 서비스에서는 테스트로 넣었던 주문들의 상태를 취소 상태로 변경하는 것을 주기적으로 처리하고 있고,\r\nLet's Encrypt SSL 인증서를 3개월마다 자동 갱신할 수 있도록 처리해놓기도 했다.  \r\n현재 개발 중인 서비스에서는 5분마다 결제 완료된 주문 정보를 찾아 주문 데이터를 생성할 수 있는 과정이 필요했고,  \r\n위의 모든 상황은 crontab의 설정으로 처리하고 있다.\r\n\r\n## cron과 crontab의 정의\r\n\r\n### cron\r\n\r\n`cron`은 유닉스 계열 컴퓨터 운영체제의 시간 기반 잡 스케쥴러이다. 좀 더 이해하기 쉽게 말하자면 유틸리티 소프트웨어로 스케쥴링 서비스의 이름이다.  \r\n일반적으로 백그라운드에서 계속 실행되고, 미리 정의된 작업을 예약 실행한다.  \r\n위에서 말했던 것처럼 주기적으로 실행해야하는 작업들에 사용한다.\r\n\r\n시스템에서 기본적으로 사용하고 있는 cron 설정은 시스템cron이라 하고 root나 일반 사용자가 자신의 cron 설정을 직접하는 경우에는 사용자cron이라고 한다.\r\n\r\n### crontab\r\n\r\ncron은 주어진 일정에 주기적으로 실행하도록 규정해놓은 `crontab` (cron table) 파일에 의해 구동된다.  \r\ncrontab 파일은 주기적으로 실행될 명령들로 구성된다.  \r\n이것도 쉽게 말하자면 cron 이라는 스케쥴링 서비스에서 반복적으로 실행시킬 내용들을 정의해놓은 파일이 crontab이라고 생각하면 된다.\r\n\r\n### crond\r\n\r\ncrond 는 cron daemon을 의미한다.  \r\ncron을 얘기할 때 백그라운드에서 실행된다고 했는데, 컴퓨터 용어로 daemon의 의미가 백그라운드에서 돌면서 여러 작업을 하는 프로그램을 말한다.  \r\ncrond는 백그라운드에서 실행되고 crontab 파일을 읽는 daemon의 이름이다.\r\n실제로 crontab의 내용을 읽어와 실행하는 것의 이름이 crond 이기 때문에 crontab의 내용이 변경되면 crond 서비스를 재시작해줘야 한다.\r\n\r\n## crontab 설정\r\n\r\ncrontab을 설정하는 방법에 두 가지가 있다.\r\n\r\n```\r\n# vi /etc/crontab\r\n\r\n# crontab -e\r\n```\r\n\r\n차이점은 `/etc/crontab`에 설정할 때는 사용자(user)까지 명시를 해줘야 하지만 `crontab -e`로 편집할 때는 쓰지 않아도 된다는 것이다.  \r\n어떤 기준으로 어디에 설정을 하는건지는.. 잘 모르겠다..  \r\n관리자 권한이 있으면 /etc/crontab, 없으면 crontab 명령어로 한다고도 하는데..  \r\n일단 우리 서비스에서는 root에서 crontab 명령어를 사용해 crontab 설정을 하고 있긴 하다.\r\n\r\n### crontab 명령어로 설정하기\r\n\r\ncrontab 명령어에는 여러 옵션이 있다.\r\n\r\n- crontab -e : 실행시킬 명령어 등록 및 편집\r\n- crontab -l : 등록되어있는 crontab 설정 확인\r\n- crontab -r : 현재 crontab에 설정되어있는 내용 삭제\r\n- crontab -u : 특정 user의 crontab을 설정할 때\r\n- crontab -i : crontab 내용 삭제 전 확인 문구 띄움\r\n\r\n### /etc/crontab에 설정하기\r\n\r\n/etc/crontab을 편집기로 열어 설정할 수 있다.\r\n\r\n<!-- ![/etc/crontab](etc_crontab.png) -->\r\n\r\n`* * * * * [user-name] [command]` 형태로 설정해야한다.\r\n\r\n## 주의사항\r\n\r\n직접 겪고 쓰는 주의사항..? 이라기보다 설정 시 확인해야할 사항이다.\r\n\r\n### 파일 권한 확인\r\n\r\n추가하려던 내용이 curl을 사용해 API를 호출하는 쉘 스크립트의 실행이였다.\r\ncron이 원하는 시간 설정대로 제대로 실행은 되고 있는데 API는 호출이 안되고 있었어서 도대체 뭐가 문제인가.. 쉘스크립트를 잘못 썼나.. 하다가 문득 파일 권한 설정에 대해 생각이 나서 확인해보니 `-rwx-r--r--` 이렇게 되어있었나.. 암튼 group과 모든 사용자의 권한에 execute가 없었다.\r\n\r\n그래서 그런건지 쉘 스크립트를 잘 읽어가긴 했는데 실행이 안된 것 같았다..ㅠㅠ\r\n파일 권한에서 execute 권한 추가해주니 바로 쉘 스크립트 실행이 잘 되었다.\r\n\r\n만약 로그를 확인했는데 아무 에러가 없는데 쉘 스크립트가 실행이 안되는 것 같을 땐 파일의 권한이 잘 설정되어있는지 확인해보는 것이 좋다!\r\n\r\n## 마무리\r\n\r\ncrontab 설정할 때마다 매번 찾아보게 되서 마침 또 다른 cronjob 등록할 상황이 생겨 정리하게 되었다.  \r\n글 안보고도 바로 설정할 수 있으면 좋긴 하겠지만 만약 헷갈린다면 이젠 내 블로그 봐야지~!\r\n\r\n참고\r\n\r\n- [cron](https://ko.wikipedia.org/wiki/Cron)\r\n- [Difference between cron, crontab, and cronjob?](https://stackoverflow.com/questions/21615673/difference-between-cron-crontab-and-cronjob)\r\n- [Difference between Cron and Crontab?](https://stackoverflow.com/questions/21789148/difference-between-cron-and-crontab)\r\n"},{"excerpt":"렌더링 엔진 렌더링 엔진의 기본적인 역할을 요청 받은 내용을 브라우저에 표시하는 것이다.\n프론트 작업 시 브라우저마다 다르게 보이는 경우를 한번쯤 겪어보는데, 브라우저마다 사용하는 렌더링 엔진이 다르기 때문이다. 렌더링 엔진들 참고하고 있는 글이 아무래도 2012년 글이다보니 크롬에서 웹킷 엔진을 사용하고 있다고 하지만 현재는 전에 얘기했던 것처럼 라는 …","fields":{"slug":"/230611-브라우저 렌더링/"},"frontmatter":{"date":"June 11, 2023","title":"브라우저 렌더링","tags":["web","브라우저"]},"rawMarkdownBody":"\r\n## 렌더링 엔진\r\n\r\n렌더링 엔진의 기본적인 역할을 요청 받은 내용을 브라우저에 표시하는 것이다.\r\n프론트 작업 시 브라우저마다 다르게 보이는 경우를 한번쯤 겪어보는데, 브라우저마다 사용하는 렌더링 엔진이 다르기 때문이다.\r\n\r\n## 렌더링 엔진들\r\n\r\n참고하고 있는 [글](https://d2.naver.com/helloworld/59361)이 아무래도 2012년 글이다보니 크롬에서 웹킷 엔진을 사용하고 있다고 하지만 현재는 전에 얘기했던 것처럼 `블링크`라는 엔진을 사용하고 있다. 블링크는 웹킷을 fork해서 구현된 엔진이다.  \r\n크로미움 기반 브라우저는 블링크(Blink), 파이어폭스는 게코(Gecko), 사파리는 웹킷(Webkit)을 사용하고 있다.\r\n\r\n## 동작 과정\r\n\r\n![렌더링 엔진 동작 과정](rendering_flow.jpg)\r\n\r\n![웹킷 동작 과정](webkit.jpg)\r\n\r\n렌더링 엔진은 통신으로부터 요청한 문서의 내용을 얻는 것으로 시작한다.\r\n\r\n### 파싱과 트리 구축\r\n\r\n#### HTML 파싱\r\n\r\n렌더링 엔진은 통신으로부터 얻어온 `HTML 문서`를 파싱하여 브라우저가 이해할 수 있는 `DOM(Document Object Model)`으로 변환시킨다. HTML을 파싱할 때에는 HTML파서로 파싱을 하고, 이것은 HTML 마크업을 파싱 트리로 변환해준다. 브라우저가 HTML 파싱을 위해 별도의 HTML파서를 생성하는 것에는 이유가 있다.\r\n\r\n1. HTML의 너그러운 속성\r\n\r\nHTML에서 시작 또는 종료 태그 등을 생략하는 경우가 있다.\r\nHTML은 암묵적으로 태그에 대한 생략이 가능하다. 이런 부분이 HTML이 유연한 문법을 가지고 있다는 것을 보여준다.\r\n\r\n2. HTML에 대한 브라우저의 관용\r\n\r\n3. 변경에 의한 재파싱, 스크립트 태그는 토큰을 추가할 수 있어 파싱이 수정될 수 있음\r\n\r\n이런 이유들로 일반적인 파서로는 HTML을 파싱할 수 없어 HTML 파서로 파싱을 한다.\r\n파싱 알고리즘은 토큰화와 트리 구축 단계로 되어있다.  \r\n토큰화는 입력값을 토큰으로 파싱하는 과정을 말하는데, HTML에서 토큰은 시작 태그, 종료 태그, 속성 이름과 속성 값이다. 토큰을 인지해 트리 생성자로 넘기고 다음 토큰을 확인하기 위해 다음 문자를 확인한다.\r\n\r\n토큰을 읽어 트리를 구축하는 파싱 단계를 거치면 브라우저는 문서(Document)와 상호작용할 수 있게 되고 문서 파싱 이후에 실행되어야 하는 지연 모드 스크립트를 파싱한다. 이때 load 이벤트가 발생한다.\r\n\r\n#### CSS 파싱\r\n\r\n브라우저는 DOM을 생성하는 동안 css를 불러오는 link를 만나면 즉시 해당 리소스에 대한 요청을 보낸다. css도 브라우저가 이해하고 처리할 수 있도록 변환해줘야 하기 때문에 HTML과 같은 방식으로 파싱하여 CSSOM을 생성한다.\r\n\r\n#### 스크립트의 진행 순서\r\n\r\nscript 태그를 만나면 script를 먼저 파싱하고 실행하게 되어있어 스크립트가 실행되는 동안 문서의 파싱은 중단된다.\r\nsrc 속성이 있는 외부 스크립트 태그를 만났을 때도 마찬가지이다.  \r\n이런 동작 방식은 스크립트에서 스크립트 아래에 있는 DOM 요소에 접근할 수 없게 하고, 용량이 큰 스크립트가 있는 경우에는 스크립트가 실행될 때까지 페이지를 볼 수 없게 된다.  \r\n그래서 `defer`라는 속성을 사용하면 문서 파싱이 중단되지 않고 파싱이 완료된 이후에 스크립트가 실행될 수 있다.  \r\n비동기로 처리할 수 있는 `async` 속성도 추가되어 별도의 맥락에 의해 파싱되고 실행될 수 있게 되었다.\r\n\r\n⭐ defer, async ⭐\r\n\r\n1. defer\r\n\r\ndefer 속성은 외부 스크립트에만 유효하다. script에 src가 없으면 defer 속성이 무시된다.  \r\n브라우저는 defer 속성이 있는 스크립트를 백그라운드에서 다운로드 한다. 따라서 defer 스크립트를 다운로드하는 중에도 HTML의 파싱을 중단하지 않는다. defer 스크립트의 실행은 페이지가 파싱이 끝나고 렌더링을 시작할 때까지(페이지 구성이 끝날 때까지) 기다린 후 실행된다.\r\n\r\nDOM이 준비된 후에 실행되긴 하지만 DOMContentLoaded 이벤트 발생 전에 실행된다.  \r\ndefer 스크립트는 HTML에 추가된 순으로 실행이 되기 때문에 defer 속성이 정의된 script 태그가 여러개일 경우 먼저 정의된 script가 실행이 된 후에 그 다음 defer 스크립트가 실행이 된다.  \r\n다운로드는 병렬적으로 진행이 되지만 실행 자체는 추가된 순서대로 진행이 된다.\r\n\r\n2. async\r\n\r\nasync 속성이 있는 스크립트는 페이지와 독립적으로 동작한다.\r\n다운로드는 defer와 마찬가지로 백그라운드에서 한다. 따라서 async 스크립트 다운로드를 기다리지 않고 HTML 페이지의 처리가 진행된다. 하지만 async 스크립트의 실행 중에는 HTML 파싱이 멈춘다.\r\n\r\n또 다른 점은 DOMContentLoaded 이벤트와 async 스크립트는 서로를 기다리지 않는다는 것이다.\r\ndefer 스크립트가 끝난 후에 DOMContentLoaded이벤트가 발생했던 것과 달리  \r\nasync 스크립트는 DOMContentLoaded의 전후로 실행될 수 있다.\r\n\r\n다른 스크립트 또한 async 스크립트를 기다리지 않고 async 스크립트 또한 다른 스크립트를 기다리지 않는다.\r\n그렇기 때문에 async 스크립트가 여러개 있는 경우에는 실행 순서가 제각각 다르다. 실행은 다운로드가 끝난 스크립트 순서대로 진행이 된다.\r\n\r\n이러한 특징으로, async는 스크립트가 독립적인 역할을 할 때 유용하다.\r\n\r\n### 렌더 트리 구축\r\n\r\nDOM 트리와 CSSOM을 결합하여 렌더 트리가 구축된다.\r\n렌더 트리는 실제로 화면에 표시되는 요소만 추려서 트리 형태로 만들고 표시해야할 순서대로 그려낼 수 있도록 트리를 생성한다. 이 단계를 Attachment 라고 한다.\r\n\r\n렌더 트리는 시각적 속성이 있는 사각형을 포함하고 있다. 너비, 높이, 위치와 같은 기하학적 정보도 포함되어 있다.\r\n\r\n#### DOM 트리와 렌더 트리\r\n\r\n이 둘은 1:1로 대응하는 관계가 아니다. 위에서 말한 것처럼 렌더 트리에는 실제 표시되는 요소만 있기 때문에 head와 같은 비시각적 요소는 포함되지 않는다. 또한 `display: none`이 할당되어있는 요소도 렌더 트리에 포함되지 않는다.\r\n\r\n여러 개의 DOM 요소와 대응하는 렌더 트리 요소도 있기도 하고(ex. select)  \r\n서로 동일한 위치에 있지 않는 경우도 있다. (float, position 속성 사용 요소)\r\n\r\n렌더 트리 생성이 끝나면 각 노드가 화면의 정확한 위치에 표시되는 `배치`가 시작되며, UI 백엔드에서 렌더 트리의 각 노드를 가로지르며 형상을 만들어내는 `그리기` 과정으로 이어진다.\r\n\r\n위의 과정들은 점진적으로 진행이 된다. 모든 HTML을 파싱할 때까지 기다리지 않고 렌더 트리 배치와 그리기 과정을 시작한다.\r\n\r\n⭐ display: none 과 visibility: hidden\r\n\r\n`display: none`은 요소가 보이지 않고 렌더 트리에서도 요소룰 제거하지만\r\n`visibility: hidden`는 요소를 보이지 않게 하지만 공간을 차지하고 있어 비어있는 사각형으로 렌더링 된다.\r\n\r\n### 렌더 트리 배치\r\n\r\n렌더 트리가 생성되면 브라우저의 뷰포트 내에서 각 노드들의 정확한 위치와 크기를 계산한다. 이 때 %, vh, vw와 같이 상대적인 위치, 크기 속성은 모두 실제 그려지는 px 단위로 변환되며 이 과정을 `Layout`(배치)이라고 한다.\r\n\r\n배치는 왼쪽에서 오른쪽, 위에서 아래로 진행된다. DOM 트리, CSSOM 트리가 변경될 때마다 재구성되는데 이걸 Reflow라고 말한다.DOM 요소의 기하학적 속성이 변경되거나, 화면의 크기가 변경될 때 reflow된다.\r\n\r\n요소 하나의 변경이 주변 요소들의 위치와 크기에 영향을 주고, 그 주변 요소들이 또 다른 요소들에게도 영향을 미치게 되어 결국에는 DOM 트리 전체에 대한 계산 작업이 발생하게 된다.  \r\n그러면 렌더 트리가 다시 업데이트가 되고 그리기 단계까지 진행이 되면서 화면에 표시가 된다. 작업 비용이 크다는 것을 알 수 있다.\r\n\r\nReflow가 일어나는 대표적 예는 다음과 같다\r\n\r\n- 브라우저 리사이징 (뷰포트 크기 변경)\r\n- 노드의 추가 및 제거\r\n- 요소의 위치, 크기 변경\r\n- 폰트 변경과 이미지 크기 변경\r\n\r\n### 렌더 트리 그리기\r\n\r\n렌더 트리의 배치가 끝나면 실제 화면을 그린다. 그리기 단계에서는 화면에 내용을 표시하기 위한 렌더 트리가 탐색되고 렌더러의 `paint` 메서드가 호출된다. 그리기는 UI 기반의 구성 요소를 사용한다.\r\n\r\n처리해야하는 스타일이 복잡할 수록 paint 단계의 소요시간이 길어지게 되는데, background-color, color 등의 단색 처리는 속도가 빠르지만 그라데이션이나 그림자 효과 등의 스타일은 paint 단계의 소요시간이 비교적 더 오래 소요된다.\r\n\r\nReflow가 일어나면 실제 화면에 표시되기 위해서는 paint 과정도 다시 수행이 되어야 하고, 이 과정을 `Repaint`라고 한다.\r\nReflow가 일어났을 때만 Repaint가 실행되는건 아니고 기하학적 변화가 아닌 이미지, 색상과 같은 요소들이 변할 경우, layout 부분을 생략하고 (계산 생략) paint 작업이 진행된다. (ex. background-color, opacity 변경)\r\n\r\n참고\r\n\r\n- [브라우저는 어떻게 동작하는가?](https://d2.naver.com/helloworld/59361)\r\n- [DOM 소개](https://developer.mozilla.org/ko/docs/Web/API/Document_Object_Model/Introduction)\r\n- [defer, async 스크립트](https://ko.javascript.info/script-async-defer)\r\n- [브라우저 렌더링 과정](https://ppoote.tistory.com/172)\r\n"},{"excerpt":"음악 나는 음악 듣는 걸 좋아한다. 언제부터 좋아했는지는 모르겠지만 음악과 관련된 것이 어렸을 때부터 나를 감싸고 있었던 것 같다. 초등학교 시절에는 피아노와 바이올린을 했고 (바이올린으로는 콩쿨에서 상도 탔었다.)\n중학교 땐 기타를 배웠고, 고등학교 때에는 아무래도 시기가 시기이다 보니 따로 악기를 배우지는 않았다. 어렸을 때부터 음악 활동을 접해서 그…","fields":{"slug":"/230610-드럼 배워보기/"},"frontmatter":{"date":"June 10, 2023","title":"드럼 배워보기","tags":["일상"]},"rawMarkdownBody":"\r\n## 음악\r\n\r\n나는 음악 듣는 걸 좋아한다.  \r\n언제부터 좋아했는지는 모르겠지만 음악과 관련된 것이 어렸을 때부터 나를 감싸고 있었던 것 같다.  \r\n초등학교 시절에는 피아노와 바이올린을 했고 (바이올린으로는 콩쿨에서 상도 탔었다.)\r\n중학교 땐 기타를 배웠고, 고등학교 때에는 아무래도 시기가 시기이다 보니 따로 악기를 배우지는 않았다.  \r\n어렸을 때부터 음악 활동을 접해서 그런건지는 모르겠지만 악기를 배우는 데에 부담감이 없고 배우고 싶은 욕구도 주기적으로 찾아온다. 그 바탕에는 어느 정도 자신감도 있다. 나는 음치, 박치는 아니라는 자신감😎  \r\n처음 배워도 어느 정도는 잘 할 수 있을 것 같다는 자신감이 있다.\r\n\r\n## 음악 취향 변천사\r\n\r\n음악 취향에는 변천사(?)가 있는데, 중학교~고1 때에는 힙합을 많이 들었고  \r\n2011년.. 나의 최애 `이적`을 알게 되고 팬이 된 이후에는 힙합은 진짜 거의 안듣고 이적 노래와 함께 그가 좋아하는 노래를 들어본다거나 옛날 노래도 거부감없이 잘 듣게 되었던 것 같다.  \r\n밴드 음악도 굉장히 좋아한다. 고등학교 때 같은 반 친구에게 헤비메탈..까지는 아니었지만 뭔가 좀 하드한 락 노래를 추천 받아서 들었었는데 강렬한 기타와 드럼 사운드에 한 때 빠졌던 기억이 있다.\r\n\r\n## 현재\r\n\r\n그리고 지금.\r\n여전히 나의 음악 취향의 기본은 이적이고 거기에 이제 밴드 음악이 더해졌다.  \r\n요즘 굉장히 좋아하는 밴드는 `너드커넥션`이다.  \r\n내가 어떤 뮤지션을 좋아하게 될 때에는 일련의 과정이 있는 것 같다.  \r\n어떤 한 곡을 들었는데 너무 좋아서 그 뮤지션의 다른 곡들을 일단 다 재생을 시켜본다.  \r\n그렇게 한 곡씩 넘기며 듣는데 대부분이 취향에 맞으면 마음이 열린다.  \r\n그 후에 라이브 무대를 찾아본다거나 그 뮤지션에 대한 정보를 찾아보면서 더 좋아하게 되고 실제 공연을 보러 가는 단계까지 간다면 입덕 완료..  \r\n공연 보는 것 자체가 좋다면 어떤 뮤지션의 공연이든 보러갈텐데 나는 아무래도 좋아하는 뮤지션이 나오는 공연이 좋긴 좋다.\r\n\r\n## 드럼 배우기\r\n\r\n그래서!\r\n내가 좋아하는 일 찾기 과정의 일환으로 오늘 드럼을 배우고 왔다.  \r\n요즘은 너드커넥션을 굉장히 좋아하고 있어서 밴드를 하고 싶은 마음이 큰데,\r\n기타는 그래도 배워본 적도 있고 집에 기타도 있어서 언제든 칠 수 있지만 드럼은 한번도 배워본 적이 없어서 해보고 싶었다.  \r\n그래서 일단 잘 맞을지 파악해보자는 마음으로 원데이클래스를 찾아보고 신청해서 배우고 왔는데..!  \r\n굉장히 재미있었다!\r\n\r\n기타는 코드 잡는 게 어려운 것들이 꽤 많다..  \r\n물론 기타치는게 너무 좋아서 연습을 엄청 많이 하면 잘 할 수 있겠지만..\r\n암튼 어려운 게 있는데 드럼은 일단 치면 소리는 나니까ㅋㅋㅋㅋ\r\n첫 시작 난이도로는 드럼이 쉬운 것 같다.  \r\n근데 이것도 물론 오늘 처음하는거라 매우 기본적인 리듬만 한거라서 그럴 수 있다.\r\n\r\n## 마무리\r\n\r\n처음 배웠는데 어느 정도 흥미를 느껴서 한달 정도 더 배워보고 싶은 마음이 들었다.\r\n내일 당장 학원 찾아볼 수도..🤣🤣  \r\n지금 해보고 싶은건 직장인 밴드 해보기인데 포지션이 굉~장히 고민이 된다.\r\n드럼도 해보고 싶고 기타도 하고 싶고 베이스도 배워보고 싶고..  \r\n다 잘하고 싶어!!\r\n\r\n악기 다 잘 다루고 싶은 마음으로 마무리😃\r\n"},{"excerpt":"OJT 첫번째 주제인 브라우저의 동작 원리. 네이버 기술 블로그에 올라온 글을 참고해서 공부하길래 똑같은 글을 읽어봤다. 근데 이 글도 애초에 탈리 가르시엘이라는 사람의 글을 번역한 글이던데\n브라우저 내부와 수백만 줄 분량의 오픈소스 렌더링 엔진의 소스 코드를 직접 분석하여 브라우저 동작을 파악한 사람의 글이라고 한다.. 대단쓰.. 브라우저의 정의 가장 …","fields":{"slug":"/230609-브라우저 정의, 기능, 기본 구조/"},"frontmatter":{"date":"June 09, 2023","title":"브라우저 정의, 기능, 기본 구조","tags":["web","브라우저"]},"rawMarkdownBody":"\r\nOJT 첫번째 주제인 브라우저의 동작 원리.  \r\n네이버 기술 블로그에 올라온 글을 참고해서 공부하길래 똑같은 글을 읽어봤다.  \r\n근데 이 글도 애초에 탈리 가르시엘이라는 사람의 글을 번역한 글이던데\r\n브라우저 내부와 수백만 줄 분량의 오픈소스 렌더링 엔진의 소스 코드를 직접 분석하여 브라우저 동작을 파악한 사람의 글이라고 한다.. 대단쓰..\r\n\r\n## 브라우저의 정의\r\n\r\n가장 먼저 브라우저가 무엇인지부터 정의를 보자.  \r\n브라우저는 웹 서버와 쌍방향으로 통신하고 HTML 문서나 파일을 출력하는 그래픽 사용자 인터페이스(GUI) 기반의 응용 소프트웨어이다.  \r\n간단하게 말하면 웹 서버에 저장된 정보를 화면에 표시하는 소프트웨어라고 할 수 있다.\r\n우리가 사용하고 있는 크롬, 사파리, 파이어폭스, 웨일 등이 브라우저다.\r\n\r\n## 브라우저의 주요 기능\r\n\r\n주요 기능은 사용자가 선택한 자원을 서버에 요청(request)하고 서버의 응답(response)을 받아 브라우저에 표시하는 것이다.\r\n자원은 보통 HTML 문서지만 CSS, Javascript, 이미지, PDF 등 다양한 형태가 될 수 있다.\r\n\r\n과거에는 브라우저마다 서로 다르게 데이터를 해석하여 보여줬는데, 이로 인해 웹 개발자가 호환성에 어려움을 겪게 되어 최근에는 대부분의 브라우저가 웹 표준화 기구인 `W3C(World Wide Web Consortium)`의 표준 명세를 따라 구현하고 있다.\r\n\r\n브라우저의 사용자 인터페이스는 표준 명세가 없는데도 서로의 장점을 모방하며 현재의 모습이 되었다.\r\n다음은 사용자 인터페이스의 일반적 요소들이다.\r\n\r\n- URI를 입력할 수 있는 주소 표시줄\r\n- 이전 버튼과 다음 버튼\r\n- 북마크\r\n- 새로 고침 버튼과 현재 문서의 로드를 중단할 수 있는 정지 버튼\r\n- 홈 버튼\r\n\r\n## 브라우저의 기본 구조\r\n\r\n이 글이 아무래도 옛날 글이라 그 사이에 기본 구조에 뭔가가 추가되었을라나 해서 검색해봤는데\r\n다 똑같이 이 이미지를 사용하고 있다ㅋㅋㅋ 아무래도 기본 구조니까.. 그런가보다.\r\n\r\n![브라우저의 주요 구성 요소](browser.jpg)\r\n\r\n#### 사용자 인터페이스 (User Interface)\r\n\r\n주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등을 말한다. 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분이다. 사용자 인터페이스의 일반적 요소라고 말한 것들이 모두 포함된다.\r\n\r\n#### 브라우저 엔진 (Browser Engine)\r\n\r\n모든 웹 브라우저의 핵심이 되는 구성 요소로, 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어한다.\r\n사용자가 주소 표시줄에 URL을 입력하면 (사용자 인터페이스) 그걸 전달받은 브라우저 엔진이 찾아오고, 찾아온 데이터를 렌더링 엔진에 전달해 화면에 보여주도록 한다.\r\n즉, 사용자가 어떤 액션을 하는 것부터(사용자 인터페이스) 화면에 결과물로 보여주기(렌더링)까지의 과정에 관여하는 것이다.\r\n\r\n#### 렌더링 엔진 (Rendering Engine)\r\n\r\n사용자가 요청한 콘텐츠를 표시해주는 역할을 한다. HTML을 요청한다면 HTML과 CSS를 파싱하여 화면에 출력해주는 것이다.\r\n\r\n브라우저 엔진을 찾다보면 렌더링 엔진이 나와서 두 개가 같은건가 싶었다.  \r\n[이 블로그](https://codecraft.tistory.com/entry/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-2-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%97%94%EC%A7%84-%EB%93%A4%EC%97%AC%EB%8B%A4%EB%B3%B4%EA%B8%B0-Webkit)에서만 구분되어 설명해줬다.\r\n그림 상으로는 구분되어 있는데 여러 곳에서 약간 동일하게 말하고 있어서 조금 헷갈림..\r\n\r\n근데 보니까 보통 브라우저 엔진은 렌더링 엔진을 의미한다고 하는 것 같고,\r\n브라우저 엔진과 렌더링 엔진의 구분보다는 자바스크립트 엔진과의 구분이 좀 더 의미있는 구분인 것 같다.\r\n\r\n브라우저 엔진 및 렌더링 엔진에는 블링크 (Blink), 웹킷(Webkit), 게코(Gecko), 서보(Servo)등이 있다.  \r\n현재 크롬, 엣지, 웨일 등 2010년 이후 등장한 대부분의 브라우저들은 블링크를 사용하고 있다고 한다.\r\n사파리는 웹킷, 파이어폭스는 게코를 사용하고 있다고 한다.\r\n\r\n#### 통신 (Networking)\r\n\r\nHTTP(HyperText Transfer Protocol) 또는 FTP(file transfer protocol)와 같은 표준 프로토콜을 사용하여 네트워크 호출을 관리하는 역할을 한다. 통신은 플랫폼 독립적인 인터페이스이고 각 플랫폼 하부에서 실행된다.\r\n\r\n브라우저는 웹 페이지를 가져오기 위해 대부분의 웹 서버가 사용하는 `HTTP(Hyper Text Transfer Protocol)`로 통신한다.\r\nHTTP는 텍스트, 이미지 및 비디오가 웹에서 전송되는 방식을 정의하는 일종의 약속이다.\r\n\r\n#### UI 백엔드 (UI Backend)\r\n\r\n콤보 박스와 창 같은 기본적인 장치를 그려준다. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, 브라우저가 동작하고 있는 운영체제(OS)의 인터페이스를 따르는 UI를 처리한다. OS에 따라 alert이나 selectbox가 다르게 보이는 것이 UI 백엔드의 영향이다.\r\n\r\n렌더링 엔진에서 생성된 렌더 트리를 브라우저에 그리는 역할을 한다.\r\n\r\n#### 자바스크립트 엔진 (Javascript Engine)\r\n\r\n자바스크립트 코드를 해석하고 실행한다. 해석한 결과를 화면에 표시하기 위해 렌더링 엔진으로 전달한다.\r\n\r\n#### 자료 저장소 (Data Storage)\r\n\r\n자료를 저장하는 계층이다. Local Storage, Session Storage, Cookie 등을 로컬에 저장하는 영역이다. HTML5 명세에는 브라우저가 지원하는 '웹 데이터 베이스'가 정의되어 있다.\r\n\r\n## 마무리\r\n\r\n내용이 많아서 나눠서 하는걸로..! 조금씩 천천히 체하지 않게 가보자!\r\n\r\n<br />\r\n참고\r\n\r\n- [브라우저는 어떻게 동작하는가?](https://d2.naver.com/helloworld/59361)\r\n- [웹 브라우저](https://ko.wikipedia.org/wiki/%EC%9B%B9_%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80)\r\n- [[브라우저 이해하기] 2. 브라우저 엔진 들여다보기 (Webkit)](https://codecraft.tistory.com/entry/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-2-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%97%94%EC%A7%84-%EB%93%A4%EC%97%AC%EB%8B%A4%EB%B3%B4%EA%B8%B0-Webkit)\r\n- [브라우저 기본 구조와 렌더링 과정](https://velog.io/@po05360/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%EC%A1%B0%EC%99%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95)\r\n"},{"excerpt":"NestJS 9.3.0 버전부터 devTools 지원하니까 버전 업데이트 하면 좋을 것 같다는 얘기에 버전 업그레이드를 진행했다.\nNestJS에서 GraphQL을 같이 사용하고 있어 graphql의 버전도 같이 업데이트 해야하는 상황이였다. 1. 패키지 업데이트 yarn을 사용하고 있어 다음의 명령어로 업데이트를 진행하였다. yarn upgrade-int…","fields":{"slug":"/230608-NestJS 버전 업데이트/"},"frontmatter":{"date":"June 08, 2023","title":"NestJS devtools 사용하려다 GraphQLModule 설정만 바꿔본 사람?","tags":["NestJS","GraphQL"]},"rawMarkdownBody":"\r\nNestJS 9.3.0 버전부터 devTools 지원하니까 버전 업데이트 하면 좋을 것 같다는 얘기에 버전 업그레이드를 진행했다.\r\nNestJS에서 GraphQL을 같이 사용하고 있어 graphql의 버전도 같이 업데이트 해야하는 상황이였다.\r\n\r\n### 1. 패키지 업데이트\r\n\r\nyarn을 사용하고 있어 다음의 명령어로 업데이트를 진행하였다.\r\n\r\n```bash\r\nyarn upgrade-interactive\r\n```\r\n\r\nyarn upgrade-interactive 명령어는 yarn outdated와 yarn upgrade를 조합한 커맨드라고 생각하면 된다.\r\n실행하면 설치되어있는 패키지들중에서 업그레이드를 하고 싶은 패키지를 선택하여 업그레이드를 진행할 수 있다.\r\n\r\n공식 문서를 보면\r\n\r\n```typescript\r\nasync function bootstrap() {\r\n  const app = await NestFactory.create(AppModule, {\r\n    snapshot: true,\r\n  })\r\n  await app.listen(3000)\r\n}\r\n```\r\n\r\nsnapshot을 추가할 수 있어야하는데 nest의 버전이 낮으면 해당 부분에서 오류가 발생해서\r\n@nestjs/core 등 주요 패키지의 업데이트를 진행했다.\r\n\r\n### 2. @nestjs/devtools-intergration 설치\r\n\r\ndevtools를 사용하기 위해서는 위 패키지를 설치해줘야한다.\r\n여기서 조금 문제가 있었는데, 계속 위 패키지를 설치하려고 하면 사내 npm 패키지 저장소를 참조하는 것이었다..\r\n공식문서에서 말하는 것처럼 @nestjs/graphql@11 로 설치를 해도 잘 안되서 그냥 @nestjs/graphql 삭제 후 다시 설치한 다음에\r\n다시 @nestjs/devtools-intergration 설치를 시도했는데 잘 넘어갔다!\r\n\r\n### 3. graphql 관련 패키지들 업그레이드의 사이드이펙트(?)\r\n\r\n@nestjs/graphql 패키지를 `10.1.7`에서 `11.0.5`로 업데이트를 하고 나니\r\n`GraphQLModule.forRoot`의 첫번째 인자로 전달하는 options 타입인 ApolloDriverConfig가 변경이 되었는지,\r\n기존에 사용하던 cors와 debug 필드가 오류를 발생하고 있었다..\r\n어떻게 변경되어서 어떻게 사용해야하는지 열심히 찾아봐야하는 상황..!\r\n\r\n#### cors\r\n\r\ncors 관련 내용은 [nestjs/graphql 레포지토리의 issues](https://github.com/nestjs/graphql/issues/2752)에서 발견하게 되었다.\r\nNestjs에서 graphql 사용할 때에는 GraphQLModule에 따로 적어줬어야 했는데 이제는 Nestjs/common에서 제공해주는 `enableCors()`를 같이 사용하면 된다고 한다.\r\n\r\n```typescript\r\nconst app = await NestFactory.create(AppModule)\r\n\r\napp.enableCors({\r\n  origin: true,\r\n  methods: \"GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS\",\r\n  credentials: true,\r\n})\r\n```\r\n\r\n#### debug\r\n\r\n이 옵션은 요청에서 오류가 발생했을 때 response로 stacktrace를 전달해줄지에 대한 옵션이였다.\r\n클라이언트에게 stacktrace까지 제공하는 것은 일반적을 권장되지 않는다 하여 `debug: false`로 사용하고 있었는데 이 옵션이 사라져버렸다..!!\r\n아무리 검색을 해도 안나오고(ㅠㅠ) ApolloDriverConfig 타입을 봐도 못찾은 상황에서\r\n그래 없을리가 없지..! 하고 다시 천천히 ApolloDriverConfig에서 extends하고 있는 타입들을 살펴보니 눈에 띄는 필드가 하나 발견되었다.\r\n바로 `includeStacktraceInErrorResponses`!\r\n\r\n굉장히 직관적인 이름으로 변경이 되어있었다ㅋㅋㅋㅋㅋ\r\n다행히 잘 찾아내서 추가해주니 이전과 동일하게 stacktrace는 제거가 잘 되었다.. 휴..\r\n\r\n### 결말\r\n\r\n변경 후 devtools는 어떻게 사용하는거지? 싶어서 다시한번 [공식문서](https://docs.nestjs.com/devtools/overview)를 읽어보았다.\r\nsnapshot 추가하고 DevtoolsModule 추가해주고 하면 사용할 수 있는 줄 알았는데\r\nhttps://devtools.nestjs.com/ 을 들어가서 로그인을 하니까 유료였다.....\r\n그냥 쓸 수 있는 줄 알고 바꾸자고 하셨던 것 같은데 알고보니 유료ㅠㅠ\r\n결국 devtools 사용은 안하는걸로 하고 어쩌다보니 nestjs 버전 업데이트와 graphql 버전 업데이트만 진행하게 된 슬픈지만 좋은 결말..?\r\n\r\n이상 만약 우리처럼 위의 옵션을 사용하고 있다가 업데이트 하고 보니 사라져서 어떻게 해야하나 싶은 분들을 위해 남기는 글이였습니다..\r\n"},{"excerpt":"시리즈는 기초를 위한 것이기도 하지만 새로 들어오실 신입분들에게 진행될 OJT에 피드백을 드릴 수 있기 위해 나부터도 다시 공부해야 할 것 같아서 시작한다.  인터넷과 웹 먼저 인터넷과 웹에 대해 간단하게 알아보자 인터넷 ( Internet ) 인터넷이란 여러 통신망을 하나로 연결한다는 의미의 인터 네트워크( inter-network ) 라는 말에서 시작…","fields":{"slug":"/230607-인터넷과 웹/"},"frontmatter":{"date":"June 07, 2023","title":"인터넷과 웹","tags":["internet","web"]},"rawMarkdownBody":"\r\n`Back to Basics` 시리즈는 기초를 위한 것이기도 하지만 새로 들어오실 신입분들에게 진행될 OJT에 피드백을 드릴 수 있기 위해 나부터도 다시 공부해야 할 것 같아서 시작한다. <br />\r\n\r\n## 인터넷과 웹\r\n\r\n먼저 인터넷과 웹에 대해 간단하게 알아보자\r\n\r\n### 인터넷 ( Internet )\r\n\r\n인터넷이란 여러 통신망을 하나로 연결한다는 의미의 인터 네트워크( inter-network ) 라는 말에서 시작되어, 지금은 전 세계 컴퓨터들을 하나로 연결하는 거대한 컴퓨터 통신망을 의미한다.\r\n\r\n1960년, 미국에서 핵에 의해 중앙집중화된 통신이 마비될 것에 대비하여 통신망을 분산시키기 위해 구축하게 된 것이 인터넷의 시작이다.<br />\r\n1983년, TCP/IP를 공식 프로토콜로 도입하면서 현대적인 컴퓨터 네트워크의 기본 구조가 갖춰졌고, 이 때 즈음 '인터넷'이 '인터네트워크'의 약자가 아닌 고유명사 취급을 받기 시작했다고 한다.<br />\r\nweb이 나타나기 전 인터넷은 기업이나 연구소, 대학, 군대와 같은 기관에서 사용하던 통신 시스템이여서 대중적이지 않았다.\r\n\r\n### 웹 ( Web )\r\n\r\n월드 와이드 웹 ( World Wide Web ) 이란 인터넷에 연결된 사용자들이 서로의 정보를 공유할 수 있는 공간을 의미한다.\r\n줄여서 WWW나 W3라고도 부르며, 간단하게 웹(Web) 이라고 가장 많이 부른다.\r\n\r\n1989년, 팀 버너스 리 라는 사람이 문자 및 그림, 음성 등 다양한 데이터를 포함한 방대한 데이터베이스를 구축한 뒤, 이를 시각적으로 표현할 수 있는 표준 문서 형식을 규정하고 문서 속에 연결된 특정 항목은 또 다른 문서로 연결되는 정보 검색 시스템을 제시했고,\r\n이것이 '월드 와이드 웹' 이라는 세계적인 정보 공유 공간 및 하이퍼 텍스트 방식의 HTML의 개념이 등장하게 되는 계기가 되었다.\r\n\r\n1991년에는 세계 최초 홈페이지가 공개되었다. (http://info.cern.ch/)\r\n\r\n팀 버너스 리는 URL, HTTP, NEXUS(세계 최초 웹브라우저) 등의 설계 및 규격 제정에 참여하면서 웹의 아버지라고 불리게 되었다고 한다.\r\n\r\n### 인터넷과 웹의 관계\r\n\r\n인터넷과 웹은 정확히 말하면 다른 개념이다.\r\n\r\n웹은 인터넷 서비스 중 하나일 뿐이고, 웹 이외에 인터넷에서 제공하는 서비스는 `FTP`, `Email` 등이 있다.\r\n인터넷은 전 세계를 연결시켜주는 네트워크 인프라이고, 이런 인터넷을 기반으로 제공되는 서비스 중 하나가 웹인 것이다.\r\n\r\n## 인터넷의 동작 원리\r\n\r\n백엔드 로드맵에 맨 처음에 위치하는 인터넷의 동작 원리..!<br />\r\nMDN 문서를 한번 읽어보았다.\r\n\r\n### 단순한 네트워크\r\n\r\n두 개의 컴퓨터가 통신을 할 때, 다른 컴퓨터와 물리적(이더넷 케이블) 또는 무선(Wi-Fi, 블루투스)으로 연결이 되어야 한다.\r\n\r\n이런 네트워크는 원하는 만큼의 컴퓨터를 연결할 수 있지만 여러 개의 컴퓨터를 연결할 수록 복잡해진다. (필요한 물리적 자원이 늘어남)\r\n\r\n이런 문제를 해결하기 위해 사용하는 것이 `라우터`이다. 라우터는 특수한 소형 컴퓨터로 A 컴퓨터에서 B 컴퓨터에 요청을 보냈을 때, B 컴퓨터로 잘 도착하도록 해준다.\r\n따라서 각 컴퓨터는 하나의 라우터에 연결되어 서로 통신할 수 있게 된다.\r\n\r\n### 네트워크 속의 네트워크\r\n\r\n이제 좀 더 확장시켜서 수십억 대의 컴퓨터를 연결하는 상황을 생각해보자.\r\n단일 라우터는 수십억 대의 컴퓨터를 연결하는 정도로 확장할 수는 없지만\r\n라우터도 마찬가지로 컴퓨터라고 했기 때문에 서로 다른 두 대의 라우터를 연결할 수 있다.\r\n컴퓨터를 라우터에 연결하고, 라우터에서 라우터로 연결하여 무한하게 확장시킬 수 있다.\r\n\r\n네트워크의 네크워크를 구현해 하나의 통신망으로 연결하는 것이 인터넷인데, 위의 방법으로는 먼 곳의 지역과는 연결이 불가능하다.\r\n따라서 전화기 기반 시설을 사용하여 범위를 더 확장시킨다.\r\n전화기 기반 시설은 이미 서계 어느 곳과도 연결되어있기 때문에 전화 시설과 연결하는 것이고, 이를 위해서는 `모뎀`이라는 장비가 필요하다.\r\n모뎀은 네트워크의 정보를 전화 시설에서 처리할 수 있는 정보로 바꿔주고 그 반대의 경우도 마찬가지이다.\r\n\r\n이제 현재 네트워크에서 다른 네트워크로 메세지를 보내는데, 이를 위해서 네트워크를 인터넷 서비스 제공 업체(Internet Service Provider, ISP)에 연결한다.\r\n(ISP의 예시로는 KT, SK텔레콤, LG유플러스 등이 있다.)\r\nISP는 모두 함께 연결되는 몇몇 특수한 라우터를 관리하고 다른 ISP의 라우터에도 액세스할 수 잇는 회사이다.\r\n따라서 현재 네트워크의 메세지는 ISP 네트워크의 네트워크를 통해 대상 네트워크로 전달되고, 인터넷은 이러한 전체 네트워크 인프라로 구성된다.\r\n\r\n### 중간 요약\r\n\r\n컴퓨터 - 라우터 - 모뎀 - 전화시설 - ISP 이렇게 연결되어 다른 컴퓨터와 통신할 수 있게 된 것.<br />\r\n각 단계는 연결을 확장시키는 단계에서 추가되었다. (두 대의 컴퓨터 연결에서 전 세계 컴퓨터 연결로의 확장)\r\n\r\n### 컴퓨터 찾기\r\n\r\n다른 컴퓨터에 메세지를 보내려면 수신할 컴퓨터를 지정해야한다. 따라서 네트워크에 연결된 모든 컴퓨터에는 IP 주소라는 고유한 주소가 있다.\r\n컴퓨터는 IP 주소로 다른 컴퓨터를 찾는데 문제가 없지만 사람은 IP 주소를 기억하기 어렵기 때문에 '도메인' 이라는 사람이 읽을 수 있는 형태의 IP 주소 이름을 지정할 수 있다.\r\n\r\n## 마무리\r\n\r\n인터넷과 웹이라는 단어는 일상에서 굉장히 많이 사용하기도 하고 아무래도 웹 개발자로서 언젠가 분명 이런 내용을 읽은 것 같긴 한데 이번에 새삼 좀 재미있게 읽었다.<br />\r\n일단 웹이라는 개념이 팀 버너스 리 라는 한 사람의 머리에서 나와서 지금까지 꾸준히 발전해온게 진짜 뭔가 대단하고 새삼 느낌..<br />\r\nURL이랑 HTTP까지.. 어떻게 한 사람이 다..?<br />\r\n그리고 생각보다 굉장히 오래 전에 인터넷이라는 개념이 생긴 것도 신기했다. <br />1960년.. 한반도 전쟁 휴전된 게 53년인데.. 7년 뒤에 인터넷..? 그걸 지금까지도..? 이런 느낌이라 재밌었다.\r\n\r\n참고\r\n\r\n- [생활코딩](https://www.youtube.com/watch?v=pYOEy_mAMpI&list=PLuHgQVnccGMDZP7FJ_ZsUrdCGH68ppvPb&index=16)\r\n- [인터넷](https://terms.naver.com/entry.naver?docId=3573476&cid=59088&categoryId=59096)\r\n- [인터넷은 어떻게 동작하는가?](https://developer.mozilla.org/ko/docs/Learn/Common_questions/Web_mechanics/How_does_the_Internet_work)\r\n"},{"excerpt":"prologue '개발자' 라는 직업을 갖게 된 지 벌써 3년 반이라는 시간이 지났다.\n깊은 고민과 생각 없이 흘러가는대로 시작하게 되어서 그런지, 지난 시간들도 '마냥 흘려보낸 것만 같다' 라는 생각을 요즘 굉장히 많이 하고 있다. 물론 진짜로 무념무상 흘려보낸건 아니긴 하지.\n내가 맡은 일을 할 때 매 순간 많은 고민과 해결책을 찾으면서 일했고, 분명…","fields":{"slug":"/230606/"},"frontmatter":{"date":"June 06, 2023","title":"새로운 시작","tags":["일상"]},"rawMarkdownBody":"\r\n## prologue\r\n\r\n'개발자' 라는 직업을 갖게 된 지 벌써 3년 반이라는 시간이 지났다.\r\n깊은 고민과 생각 없이 흘러가는대로 시작하게 되어서 그런지, 지난 시간들도 '마냥 흘려보낸 것만 같다' 라는 생각을 요즘 굉장히 많이 하고 있다.\r\n\r\n물론 진짜로 무념무상 흘려보낸건 아니긴 하지.\r\n내가 맡은 일을 할 때 매 순간 많은 고민과 해결책을 찾으면서 일했고, 분명 처음 시작했을 때보다는 아는건 많아졌을거라 생각한다.\r\n그럼에도 지금 느끼고 있는 지난 시간들에 대한 후회는 무엇 때문일까.\r\n후회인지 회의감인지 뭔지 모를 감정에 휩쓸리고 있는게 현재 내 상태..\r\n\r\n이런 상황에서 새롭게 블로그를 만들어 글을 써보려고 하는 것은 하루하루 기록을 남기면서 나 자신에 대해서도 생각을 해보고,\r\n개발하면서 보고 배운 내용들도 정리를 해보기 위해서이다.\r\n분명 좋은 팀을 만나 3년 6개월동안 많은 것을 배웠는데 글로써 남아있는 것이 별로 없다보니 내가 무엇을 어떻게 했었는지 생각해내는 것이 어렵기도 하고,\r\n분명 일할 때 찾아보면서 적용시킨 내용들인데 오랫동안 기억에 남지 않아 같은 내용이더라도 찾아보게 되는 순간들이 있어서\r\n이젠 정말 기록을 잘 남겨보려고 한다.\r\n\r\n### 고민\r\n\r\n요즘 고민을 하고 있는건 나에게 '개발자'라는 직업이 잘 맞는건가? 하는 것인데 사실 잘 모르겠다.\r\n애초에 정말 싫다 싶었으면 학부 때 전공으로 선택을 안했을 것이고, 취업 준비할 때에도 선택지에서 제외를 시켰을 것 같은데\r\n'개발' 자체가 선택지에 없었던 적이 없긴 하다.\r\n그냥 다들 원래 무난하게 전공 살려서 취업하는거 아니야? 라고 생각하며 살았는데\r\n'개발자'라는 직업을 정말 하고 싶어서 시작하는 사람들을 보다 보니 이런 고민을 하게 되는 것 같다.\r\n(이게 지금 후회인지 회의감인지 뭔지 모를 그 감정의 원인인 듯..!)\r\n\r\n3년 6개월이라는 기간 중에 이런 생각을 한게 이번이 처음은 아니었다.\r\n뭔가 내가 무능력하다고 느껴지거나 나에 대한 확신이 없어질 때마다 이런 생각을 한 것 같긴 하다.\r\n언제인지 기억은 안나지만 한 1년 안되었을 때였던 것 같긴 한데\r\n회사에서 내가 맡은 일 중에 정말 안풀리고 어떻게 해야할지 모르겠는 일이 있었을 때,\r\n지금 와서 생각해보면 동기나 사수나 팀장님한테 솔직하게 말했어도 좋았겠다 싶지만\r\n그때의 나는 회사에서 순간순간 터지려는 눈물을 참으면서 하기도 했다.\r\n일은 잘 해결되었지만 이런 상황이 있을 때마다 나는 '내가 정말 잘하고 있는걸까?'라는 생각을 했던 것 같다.\r\n\r\n이런 생각을 진짜 요즘 매일 하게 되는데 그러다보니 좀 지쳐서..\r\n일단은 개발 공부에 시간을 투자해보자! 가 결론이 되었다.\r\n일할 때 정말 행복해 죽을 것처럼 하면 물론 좋겠지만 현재의 나는 일단 그런 사람은 아니다.\r\n그렇다고 잘하고 싶은 욕심이 없는 것도 아니다..\r\n잘하고 싶은 욕심이 없었으면 그냥 되는대로 살았을 것 같은데 그렇지는 않았다고 생각한다.\r\n나름 책도 읽고 강의도 들으면서 지식을 쌓으려고 노력도 하고\r\n새로운 기술 적용할 때도 '아.. 나는 진짜 능력이 없나.. 왜이렇게 못하냐..' 라고 생각하면서도 결국엔 하긴 하는걸 보면 그냥 평균 정도는 하지 않나 싶은..\r\n그래서 일단은 개발 공부에 들이는 시간을 늘려보면 자기 확신이 생기지 않을까 싶어 새롭게 블로그도 만든 것.\r\n\r\n개발 관련 공부도 하면서 내가 뭘 좋아하는지 찾아보는 것도 끊임없이 시도해볼 생각이다.\r\n스스로에게 질문을 했을 때 '모르겠다' 라는 답이 많은 인간이다.\r\n내가 나한테 질문하는데 왜 모르지? 나는 왜 내 자신이 제일 어렵지?\r\n이게 진짜로 모르는건지 아니면 내 자신조차 속이는건지 정말로 '모르겠다'...\r\n너무 어려워.. 어쩌다 이런 인간이 되어버린건지 모르겠지만\r\n조금 더 자신에게 솔직한 사람이 되기 위해 고민도 많이 해보려고 한다.\r\n최대한 '모르겠다'라는 답을 하지 않기 위해 노력하는게 1순위일 듯ㅠㅠ\r\n\r\n### 마무리\r\n\r\n첫 게시글이 이런.. 고민만 잔뜩 적은 글이 되어버렸지만 중요한 과정이라고 생각한다. 나 자신을 찾는 것과 개발에 시간을 투자하는 것 모두.\r\n최근에 두 분께 '다재다능한 면이 있다' 라는 말과 '잠재력이 충분히 있는 사람이다' 라는 말이 굉장히 감사했고 눈물이 날 것 같았다. 나는 이렇게 내 자신에 대해 확신이 없고 자신감이 없는데 이렇게 봐주는 사람도 있네 싶어서 왜인지 미안한 느낌도 들었다. 지금은 이런 얘길 들어도 없던 확신이 생기지 않지만 하고 싶은 게 확실해졌을 때, 이런 말도 자신있게 받아들일 수 있는 사람이 되고 싶다. 30살 이전엔 한번 찾아보자고! 이제 만나이로 바뀌니까 아직 1년 남았다!!!😂😂\r\n"}]}},"pageContext":{}},"staticQueryHashes":[]}