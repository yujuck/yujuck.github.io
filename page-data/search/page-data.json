{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"지금은 기본 중의 기본이 되어있는 ES6인데 글을 쓰는 이유는..? ES6 이후에 나온 내용들도 한번 쭉 보고 싶어서 시리즈로 만들기 위해 적어보려고 한다! ECMAScript? ES? Ecma International이 기술 규격에 따라 정의하고 있는 표준화된 스크립트 프로그래밍 언어 Javascript는 Netscape 회사의 Brendan Eich …","fields":{"slug":"/230615-ES6 문법 1탄/"},"frontmatter":{"date":"June 15, 2023","title":"ES6(ECMAScript 6) 알아보기 - let, const, 화살표 함수, 스프레드 연산자","tags":["javascript","ES6"]},"rawMarkdownBody":"\r\n지금은 기본 중의 기본이 되어있는 ES6인데 글을 쓰는 이유는..?  \r\nES6 이후에 나온 내용들도 한번 쭉 보고 싶어서 시리즈로 만들기 위해 적어보려고 한다!\r\n\r\n## ECMAScript? ES?\r\n\r\n> Ecma International이 `ECMA-262`기술 규격에 따라 정의하고 있는 표준화된 스크립트 프로그래밍 언어\r\n\r\nJavascript는 Netscape 회사의 Brendan Eich 라는 사람에 의해 최초로 개발되었다. 그 후 Javascript의 성공에 자극을 받은 마이크로소프트는 Jscript 라는 언어를 개발하고 IE에 지원되기 시작했다.  \r\n두 스크립트가 서로 호환되지 못하는 경우가 생기게 되면서 표준화가 요구되었고, ECMA-262의 이름으로 1996년 11월부터 시작됐다.\r\n\r\n`ES`는 `ECMAScript의 약자`다. 헷갈릴 수 있는 게 `ES6`는 ES016이 아니라 `ES2015`와 `동일`하다.\r\n현재는 ES6보다 더 많은 버전이 나와있는데도 최신 버전의 내용보다 ES6의 내용을 중요하게 보는 데에는 이유가 있다.\r\n\r\n먼저, ES6에 추가된 개념들이 ES6 이하 버전에서 문제가 되었던 부분들이 해결되고 많은 기능이 추가되어 현재까지도 중요한 개념들이기 때문이다. 그리고 구버전의 웹 브라우저나 레거시 코드와의 호환성 문제가 있어 대부분의 기업들이 ES6까지를 호환성의 최대치로 보고 있다고 한다.\r\n\r\n## ES6 하나씩 알아보기\r\n\r\n### let, const\r\n\r\n이제는 너무 기본적인 `let` 과 `const`.\r\n\r\n블록 스코프의 변수 선언을 할 수 있게 되었다. var와의 가장 큰 차이점이 바로 함수 스코프가 아닌 블록 스코프 변수 선언이라는 것이다.\r\n\r\n`let`과 `const`의 차이점은 const는 한번 초기화하면 다른 값을 정의할 수 없지만 let은 계속 값을 변경할 수 있다. 주의할 점은 const여도 객체나 배열의 요소의 변경을 막진 않는 다는 것이다.\r\n\r\n호이스팅에 대한 얘기도 무조건 나온다.\r\n\r\nvar 키워드와 달리 let과 const는 변수 호이스팅이 발생하지 않는 것처럼 동작한다.\r\n\r\n```\r\nconsole.log(x);  // ReferenceError\r\nlet x;\r\n```\r\n\r\nvar 키워드로 선언했다면 위의 상황에서 ReferenceError가 아닌 undefined가 출력되었을 것이다.  \r\n`var` 키워드 변수는 런타임 이전에 선언 단계와 초기화 단계가 `한번에 진행`되는데,  \r\n`let` 키워드 변수는 선언 단계와 초기화 단계가 `분리되어 진행`된다.  \r\n즉, 런타임 이전에 선언 단계가 먼저 실행되지만 `초기화 단계는 변수 선언문에 도달했을 때 실행`된다.\r\n\r\n초기화 단계가 실행되기 이전에 변수에 접근하려고 하면 참조 에러(ReferenceError)가 발생한다.  \r\nlet 키워드 변수는 스코프 시작 지점부터 초기화 단계가 실행되는 변수 선언문까지는 변수를 참조할 수 없는데,\r\n이 구간을 `일시적 사각지대`(Temporal Dead Zone: TDZ) 라고 한다.\r\n\r\n위의 특성 때문에 변수 호이스팅이 발생하지 않는 것처럼 보이지만 그렇지는 않다.\r\n\r\n```\r\nlet x = 1;  // 전역변수\r\n{\r\n    console.log(x);  // ReferenceError\r\n    let x = 2;  // 지역변수\r\n}\r\n```\r\n\r\n변수 호이스팅이 발생하지 않는다면 위 예제는 전역 변수 x의 값을 출력해야하는데,\r\n그렇지 않고 ReferenceError가 발생한다.  \r\n-> 호이스팅이 발생했기 때문에 지역 변수 x의 존재를 알고 있지만 값이 초기화 되어있지 않아서 ReferenceError가 발생\r\n\r\n자바스크립트는 ES6에서 도입된 let, const를 포함해서 모든 선언(var, let ,const, function, class 등)을 호이스팅 한다.  \r\n단, ES6에서 도입된 let, const class를 사용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작한다.\r\n\r\n### 화살표 함수 (Arrow Function)\r\n\r\n```javascript\r\n// ES5\r\nvar x = function (x, y) {\r\n  return x * y;\r\n};\r\n\r\n// ES6\r\nconst x = (x, y) => x * y;\r\n```\r\n\r\n화살표 함수의 가장 큰 특징은 `this`가 상위 스코프의 this로 유지가 된다는 것이다.\r\n항상 익명함수로 정의하고, 생성자 함수로 사용할 수도 없다. 또한 prototype 프로퍼티가 없고 arguments 객체를 생성하지 않는다는 특징이 있다.\r\n\r\n### 스프레드 연산자 (Spread Operator)\r\n\r\n스프레드 연산자 (...) 은 반복 가능한(iterable) 객체에 적용할 수 있는 문법이다. 배열, 문자열 등의 요소 하나하나를 spread 시켜주는 문법이다.\r\n\r\n```javascript\r\nconst arr = [1, 2, 3, 4];\r\n\r\nconsole.log(...arr); // 1, 2, 3, 4\r\n```\r\n\r\n스프레드 연산자는 여러 배열을 하나로 합칠 때도 유용하다.\r\n\r\n```javascript\r\nconst arr1 = [\"a\", \"b\", \"c\"];\r\nconst arr2 = [\"d\", \"e\", \"f\"];\r\n\r\nconst result = [...arr1, ...arr2]; // ['a', 'b', 'c', 'd', 'e', 'f']\r\n```\r\n\r\n객체도 iterable 하기 때문에 스프레드 연산자를 사용할 수 있다.\r\n\r\n```javascript\r\nconst obj = {\r\n  a: 1,\r\n};\r\n\r\nconst obj2 = { ...obj }; // { a: 1 }\r\n```\r\n\r\n이때 깊은 복사 즉, obj와 obj2는 다른 주소값을 가지게 되는데(obj를 변경해도 obj2가 변하지 않음), 이런 깊은 복사는 1depth에 한해서만 가능하다.\r\n\r\n```javascript\r\nconst numbers = [23, 55, 21, 87, 56];\r\nlet maxValue = Math.max(...numbers);\r\n```\r\n\r\n배열의 요소를 함수의 인자로 사용하려는 경우, 위처럼 작성할 수 있고\r\n\r\n```javascript\r\nfunction myFunction(v, w, x, y, z) {}\r\nconst args = [0, 1];\r\nmyFunction(-1, ...args, 2, ...[3]);\r\n```\r\n\r\n이렇게 여러 번 사용할 수도 있다.\r\n\r\n참고\r\n\r\n- [ECMA스크립트](https://ko.wikipedia.org/wiki/ECMA%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8)\r\n- [ES6](https://velog.io/@krungy/ES6)\r\n- [Javascript ES6](https://www.w3schools.com/js/js_es6.asp)\r\n- [ECMAScript](https://www.zerocho.com/category/ECMAScript)\r\n"},{"excerpt":"서비스를 개발하다보면 주기적으로 처리되어야 하는 작업들이 있다. 우리 서비스에서는 테스트로 넣었던 주문들의 상태를 취소 상태로 변경하는 것을 주기적으로 처리하고 있고,\nLet's Encrypt SSL 인증서를 3개월마다 자동 갱신할 수 있도록 처리해놓기도 했다. 현재 개발 중인 서비스에서는 5분마다 결제 완료된 주문 정보를 찾아 주문 데이터를 생성할 수 …","fields":{"slug":"/230612-crontab 설정을 해보자/"},"frontmatter":{"date":"June 12, 2023","title":"crontab 설정을 해보자","tags":["crontab","linux","ubuntu"]},"rawMarkdownBody":"\r\n서비스를 개발하다보면 주기적으로 처리되어야 하는 작업들이 있다.  \r\n우리 서비스에서는 테스트로 넣었던 주문들의 상태를 취소 상태로 변경하는 것을 주기적으로 처리하고 있고,\r\nLet's Encrypt SSL 인증서를 3개월마다 자동 갱신할 수 있도록 처리해놓기도 했다.  \r\n현재 개발 중인 서비스에서는 5분마다 결제 완료된 주문 정보를 찾아 주문 데이터를 생성할 수 있는 과정이 필요했고,  \r\n위의 모든 상황은 crontab의 설정으로 처리하고 있다.\r\n\r\n## cron과 crontab의 정의\r\n\r\n### cron\r\n\r\n`cron`은 유닉스 계열 컴퓨터 운영체제의 시간 기반 잡 스케쥴러이다. 좀 더 이해하기 쉽게 말하자면 유틸리티 소프트웨어로 스케쥴링 서비스의 이름이다.  \r\n일반적으로 백그라운드에서 계속 실행되고, 미리 정의된 작업을 예약 실행한다.  \r\n위에서 말했던 것처럼 주기적으로 실행해야하는 작업들에 사용한다.\r\n\r\n시스템에서 기본적으로 사용하고 있는 cron 설정은 시스템cron이라 하고 root나 일반 사용자가 자신의 cron 설정을 직접하는 경우에는 사용자cron이라고 한다.\r\n\r\n### crontab\r\n\r\ncron은 주어진 일정에 주기적으로 실행하도록 규정해놓은 `crontab` (cron table) 파일에 의해 구동된다.  \r\ncrontab 파일은 주기적으로 실행될 명령들로 구성된다.  \r\n이것도 쉽게 말하자면 cron 이라는 스케쥴링 서비스에서 반복적으로 실행시킬 내용들을 정의해놓은 파일이 crontab이라고 생각하면 된다.\r\n\r\n### crond\r\n\r\ncrond 는 cron daemon을 의미한다.  \r\ncron을 얘기할 때 백그라운드에서 실행된다고 했는데, 컴퓨터 용어로 daemon의 의미가 백그라운드에서 돌면서 여러 작업을 하는 프로그램을 말한다.  \r\ncrond는 백그라운드에서 실행되고 crontab 파일을 읽는 daemon의 이름이다.\r\n실제로 crontab의 내용을 읽어와 실행하는 것의 이름이 crond 이기 때문에 crontab의 내용이 변경되면 crond 서비스를 재시작해줘야 한다.\r\n\r\n## crontab 설정\r\n\r\ncrontab을 설정하는 방법에 두 가지가 있다.\r\n\r\n```\r\n# vi /etc/crontab\r\n\r\n# crontab -e\r\n```\r\n\r\n차이점은 `/etc/crontab`에 설정할 때는 사용자(user)까지 명시를 해줘야 하지만 `crontab -e`로 편집할 때는 쓰지 않아도 된다는 것이다.  \r\n어떤 기준으로 어디에 설정을 하는건지는.. 잘 모르겠다..  \r\n관리자 권한이 있으면 /etc/crontab, 없으면 crontab 명령어로 한다고도 하는데..  \r\n일단 우리 서비스에서는 root에서 crontab 명령어를 사용해 crontab 설정을 하고 있긴 하다.\r\n\r\n### crontab 명령어로 설정하기\r\n\r\ncrontab 명령어에는 여러 옵션이 있다.\r\n\r\n- crontab -e : 실행시킬 명령어 등록 및 편집\r\n- crontab -l : 등록되어있는 crontab 설정 확인\r\n- crontab -r : 현재 crontab에 설정되어있는 내용 삭제\r\n- crontab -u : 특정 user의 crontab을 설정할 때\r\n- crontab -i : crontab 내용 삭제 전 확인 문구 띄움\r\n\r\n### /etc/crontab에 설정하기\r\n\r\n/etc/crontab을 편집기로 열어 설정할 수 있다.\r\n\r\n- - - - - [user-name] [command] 형태로 설정해야한다.\r\n\r\n## 주의사항\r\n\r\n직접 겪고 쓰는 주의사항..? 이라기보다 설정 시 확인해야할 사항이다.\r\n\r\n### 파일 권한 확인\r\n\r\n추가하려던 내용이 curl을 사용해 API를 호출하는 쉘 스크립트의 실행이였다.\r\ncron이 원하는 시간 설정대로 제대로 실행은 되고 있는데 API는 호출이 안되고 있었어서 도대체 뭐가 문제인가.. 쉘스크립트를 잘못 썼나.. 하다가 문득 파일 권한 설정에 대해 생각이 나서 확인해보니 `-rwx-r--r--` 이렇게 되어있었나.. 암튼 group과 모든 사용자의 권한에 execute가 없었다.\r\n\r\n그래서 그런건지 쉘 스크립트를 잘 읽어가긴 했는데 실행이 안된 것 같았다..ㅠㅠ\r\n파일 권한에서 execute 권한 추가해주니 바로 쉘 스크립트 실행이 잘 되었다.\r\n\r\n만약 로그를 확인했는데 아무 에러가 없는데 쉘 스크립트가 실행이 안되는 것 같을 땐 파일의 권한이 잘 설정되어있는지 확인해보는 것이 좋다!\r\n\r\n## 마무리\r\n\r\ncrontab 설정할 때마다 매번 찾아보게 되서 마침 또 다른 cronjob 등록할 상황이 생겨 정리하게 되었다.  \r\n글 안보고도 바로 설정할 수 있으면 좋긴 하겠지만 만약 헷갈린다면 이젠 내 블로그 봐야지~!\r\n\r\n참고\r\n\r\n- [cron](https://ko.wikipedia.org/wiki/Cron)\r\n- [Difference between cron, crontab, and cronjob?](https://stackoverflow.com/questions/21615673/difference-between-cron-crontab-and-cronjob)\r\n- [Difference between Cron and Crontab?](https://stackoverflow.com/questions/21789148/difference-between-cron-and-crontab)\r\n"},{"excerpt":"렌더링 엔진 렌더링 엔진의 기본적인 역할을 요청 받은 내용을 브라우저에 표시하는 것이다.\n프론트 작업 시 브라우저마다 다르게 보이는 경우를 한번쯤 겪어보는데, 브라우저마다 사용하는 렌더링 엔진이 다르기 때문이다. 렌더링 엔진들 참고하고 있는 글이 아무래도 2012년 글이다보니 크롬에서 웹킷 엔진을 사용하고 있다고 하지만 현재는 전에 얘기했던 것처럼 라는 …","fields":{"slug":"/230611-브라우저 렌더링/"},"frontmatter":{"date":"June 11, 2023","title":"브라우저 렌더링","tags":["web","브라우저"]},"rawMarkdownBody":"\r\n## 렌더링 엔진\r\n\r\n렌더링 엔진의 기본적인 역할을 요청 받은 내용을 브라우저에 표시하는 것이다.\r\n프론트 작업 시 브라우저마다 다르게 보이는 경우를 한번쯤 겪어보는데, 브라우저마다 사용하는 렌더링 엔진이 다르기 때문이다.\r\n\r\n## 렌더링 엔진들\r\n\r\n참고하고 있는 [글](https://d2.naver.com/helloworld/59361)이 아무래도 2012년 글이다보니 크롬에서 웹킷 엔진을 사용하고 있다고 하지만 현재는 전에 얘기했던 것처럼 `블링크`라는 엔진을 사용하고 있다. 블링크는 웹킷을 fork해서 구현된 엔진이다.  \r\n크로미움 기반 브라우저는 블링크(Blink), 파이어폭스는 게코(Gecko), 사파리는 웹킷(Webkit)을 사용하고 있다.\r\n\r\n## 동작 과정\r\n\r\n![렌더링 엔진 동작 과정](rendering_flow.jpg)\r\n\r\n![웹킷 동작 과정](webkit.jpg)\r\n\r\n렌더링 엔진은 통신으로부터 요청한 문서의 내용을 얻는 것으로 시작한다.\r\n\r\n### 파싱과 트리 구축\r\n\r\n#### HTML 파싱\r\n\r\n렌더링 엔진은 통신으로부터 얻어온 `HTML 문서`를 파싱하여 브라우저가 이해할 수 있는 `DOM(Document Object Model)`으로 변환시킨다. HTML을 파싱할 때에는 HTML파서로 파싱을 하고, 이것은 HTML 마크업을 파싱 트리로 변환해준다. 브라우저가 HTML 파싱을 위해 별도의 HTML파서를 생성하는 것에는 이유가 있다.\r\n\r\n1. HTML의 너그러운 속성\r\n\r\nHTML에서 시작 또는 종료 태그 등을 생략하는 경우가 있다.\r\nHTML은 암묵적으로 태그에 대한 생략이 가능하다. 이런 부분이 HTML이 유연한 문법을 가지고 있다는 것을 보여준다.\r\n\r\n2. HTML에 대한 브라우저의 관용\r\n\r\n3. 변경에 의한 재파싱, 스크립트 태그는 토큰을 추가할 수 있어 파싱이 수정될 수 있음\r\n\r\n이런 이유들로 일반적인 파서로는 HTML을 파싱할 수 없어 HTML 파서로 파싱을 한다.\r\n파싱 알고리즘은 토큰화와 트리 구축 단계로 되어있다.  \r\n토큰화는 입력값을 토큰으로 파싱하는 과정을 말하는데, HTML에서 토큰은 시작 태그, 종료 태그, 속성 이름과 속성 값이다. 토큰을 인지해 트리 생성자로 넘기고 다음 토큰을 확인하기 위해 다음 문자를 확인한다.\r\n\r\n토큰을 읽어 트리를 구축하는 파싱 단계를 거치면 브라우저는 문서(Document)와 상호작용할 수 있게 되고 문서 파싱 이후에 실행되어야 하는 지연 모드 스크립트를 파싱한다. 이때 load 이벤트가 발생한다.\r\n\r\n#### CSS 파싱\r\n\r\n브라우저는 DOM을 생성하는 동안 css를 불러오는 link를 만나면 즉시 해당 리소스에 대한 요청을 보낸다. css도 브라우저가 이해하고 처리할 수 있도록 변환해줘야 하기 때문에 HTML과 같은 방식으로 파싱하여 CSSOM을 생성한다.\r\n\r\n#### 스크립트의 진행 순서\r\n\r\nscript 태그를 만나면 script를 먼저 파싱하고 실행하게 되어있어 스크립트가 실행되는 동안 문서의 파싱은 중단된다.\r\nsrc 속성이 있는 외부 스크립트 태그를 만났을 때도 마찬가지이다.  \r\n이런 동작 방식은 스크립트에서 스크립트 아래에 있는 DOM 요소에 접근할 수 없게 하고, 용량이 큰 스크립트가 있는 경우에는 스크립트가 실행될 때까지 페이지를 볼 수 없게 된다.  \r\n그래서 `defer`라는 속성을 사용하면 문서 파싱이 중단되지 않고 파싱이 완료된 이후에 스크립트가 실행될 수 있다.  \r\n비동기로 처리할 수 있는 `async` 속성도 추가되어 별도의 맥락에 의해 파싱되고 실행될 수 있게 되었다.\r\n\r\n⭐ defer, async ⭐\r\n\r\n1. defer\r\n\r\ndefer 속성은 외부 스크립트에만 유효하다. script에 src가 없으면 defer 속성이 무시된다.  \r\n브라우저는 defer 속성이 있는 스크립트를 백그라운드에서 다운로드 한다. 따라서 defer 스크립트를 다운로드하는 중에도 HTML의 파싱을 중단하지 않는다. defer 스크립트의 실행은 페이지가 파싱이 끝나고 렌더링을 시작할 때까지(페이지 구성이 끝날 때까지) 기다린 후 실행된다.\r\n\r\nDOM이 준비된 후에 실행되긴 하지만 DOMContentLoaded 이벤트 발생 전에 실행된다.  \r\ndefer 스크립트는 HTML에 추가된 순으로 실행이 되기 때문에 defer 속성이 정의된 script 태그가 여러개일 경우 먼저 정의된 script가 실행이 된 후에 그 다음 defer 스크립트가 실행이 된다.  \r\n다운로드는 병렬적으로 진행이 되지만 실행 자체는 추가된 순서대로 진행이 된다.\r\n\r\n2. async\r\n\r\nasync 속성이 있는 스크립트는 페이지와 독립적으로 동작한다.\r\n다운로드는 defer와 마찬가지로 백그라운드에서 한다. 따라서 async 스크립트 다운로드를 기다리지 않고 HTML 페이지의 처리가 진행된다. 하지만 async 스크립트의 실행 중에는 HTML 파싱이 멈춘다.\r\n\r\n또 다른 점은 DOMContentLoaded 이벤트와 async 스크립트는 서로를 기다리지 않는다는 것이다.\r\ndefer 스크립트가 끝난 후에 DOMContentLoaded이벤트가 발생했던 것과 달리  \r\nasync 스크립트는 DOMContentLoaded의 전후로 실행될 수 있다.\r\n\r\n다른 스크립트 또한 async 스크립트를 기다리지 않고 async 스크립트 또한 다른 스크립트를 기다리지 않는다.\r\n그렇기 때문에 async 스크립트가 여러개 있는 경우에는 실행 순서가 제각각 다르다. 실행은 다운로드가 끝난 스크립트 순서대로 진행이 된다.\r\n\r\n이러한 특징으로, async는 스크립트가 독립적인 역할을 할 때 유용하다.\r\n\r\n### 렌더 트리 구축\r\n\r\nDOM 트리와 CSSOM을 결합하여 렌더 트리가 구축된다.\r\n렌더 트리는 실제로 화면에 표시되는 요소만 추려서 트리 형태로 만들고 표시해야할 순서대로 그려낼 수 있도록 트리를 생성한다. 이 단계를 Attachment 라고 한다.\r\n\r\n렌더 트리는 시각적 속성이 있는 사각형을 포함하고 있다. 너비, 높이, 위치와 같은 기하학적 정보도 포함되어 있다.\r\n\r\n#### DOM 트리와 렌더 트리\r\n\r\n이 둘은 1:1로 대응하는 관계가 아니다. 위에서 말한 것처럼 렌더 트리에는 실제 표시되는 요소만 있기 때문에 head와 같은 비시각적 요소는 포함되지 않는다. 또한 `display: none`이 할당되어있는 요소도 렌더 트리에 포함되지 않는다.\r\n\r\n여러 개의 DOM 요소와 대응하는 렌더 트리 요소도 있기도 하고(ex. select)  \r\n서로 동일한 위치에 있지 않는 경우도 있다. (float, position 속성 사용 요소)\r\n\r\n렌더 트리 생성이 끝나면 각 노드가 화면의 정확한 위치에 표시되는 `배치`가 시작되며, UI 백엔드에서 렌더 트리의 각 노드를 가로지르며 형상을 만들어내는 `그리기` 과정으로 이어진다.\r\n\r\n위의 과정들은 점진적으로 진행이 된다. 모든 HTML을 파싱할 때까지 기다리지 않고 렌더 트리 배치와 그리기 과정을 시작한다.\r\n\r\n⭐ display: none 과 visibility: hidden\r\n\r\n`display: none`은 요소가 보이지 않고 렌더 트리에서도 요소룰 제거하지만\r\n`visibility: hidden`는 요소를 보이지 않게 하지만 공간을 차지하고 있어 비어있는 사각형으로 렌더링 된다.\r\n\r\n### 렌더 트리 배치\r\n\r\n렌더 트리가 생성되면 브라우저의 뷰포트 내에서 각 노드들의 정확한 위치와 크기를 계산한다. 이 때 %, vh, vw와 같이 상대적인 위치, 크기 속성은 모두 실제 그려지는 px 단위로 변환되며 이 과정을 `Layout`(배치)이라고 한다.\r\n\r\n배치는 왼쪽에서 오른쪽, 위에서 아래로 진행된다. DOM 트리, CSSOM 트리가 변경될 때마다 재구성되는데 이걸 Reflow라고 말한다.DOM 요소의 기하학적 속성이 변경되거나, 화면의 크기가 변경될 때 reflow된다.\r\n\r\n요소 하나의 변경이 주변 요소들의 위치와 크기에 영향을 주고, 그 주변 요소들이 또 다른 요소들에게도 영향을 미치게 되어 결국에는 DOM 트리 전체에 대한 계산 작업이 발생하게 된다.  \r\n그러면 렌더 트리가 다시 업데이트가 되고 그리기 단계까지 진행이 되면서 화면에 표시가 된다. 작업 비용이 크다는 것을 알 수 있다.\r\n\r\nReflow가 일어나는 대표적 예는 다음과 같다\r\n\r\n- 브라우저 리사이징 (뷰포트 크기 변경)\r\n- 노드의 추가 및 제거\r\n- 요소의 위치, 크기 변경\r\n- 폰트 변경과 이미지 크기 변경\r\n\r\n### 렌더 트리 그리기\r\n\r\n렌더 트리의 배치가 끝나면 실제 화면을 그린다. 그리기 단계에서는 화면에 내용을 표시하기 위한 렌더 트리가 탐색되고 렌더러의 `paint` 메서드가 호출된다. 그리기는 UI 기반의 구성 요소를 사용한다.\r\n\r\n처리해야하는 스타일이 복잡할 수록 paint 단계의 소요시간이 길어지게 되는데, background-color, color 등의 단색 처리는 속도가 빠르지만 그라데이션이나 그림자 효과 등의 스타일은 paint 단계의 소요시간이 비교적 더 오래 소요된다.\r\n\r\nReflow가 일어나면 실제 화면에 표시되기 위해서는 paint 과정도 다시 수행이 되어야 하고, 이 과정을 `Repaint`라고 한다.\r\nReflow가 일어났을 때만 Repaint가 실행되는건 아니고 기하학적 변화가 아닌 이미지, 색상과 같은 요소들이 변할 경우, layout 부분을 생략하고 (계산 생략) paint 작업이 진행된다. (ex. background-color, opacity 변경)\r\n\r\n참고\r\n\r\n- [브라우저는 어떻게 동작하는가?](https://d2.naver.com/helloworld/59361)\r\n- [DOM 소개](https://developer.mozilla.org/ko/docs/Web/API/Document_Object_Model/Introduction)\r\n- [defer, async 스크립트](https://ko.javascript.info/script-async-defer)\r\n- [브라우저 렌더링 과정](https://ppoote.tistory.com/172)\r\n"},{"excerpt":"음악 나는 음악 듣는 걸 좋아한다. 언제부터 좋아했는지는 모르겠지만 음악과 관련된 것이 어렸을 때부터 나를 감싸고 있었던 것 같다. 초등학교 시절에는 피아노와 바이올린을 했고 (바이올린으로는 콩쿨에서 상도 탔었다.)\n중학교 땐 기타를 배웠고, 고등학교 때에는 아무래도 시기가 시기이다 보니 따로 악기를 배우지는 않았다. 어렸을 때부터 음악 활동을 접해서 그…","fields":{"slug":"/230610-드럼 배워보기/"},"frontmatter":{"date":"June 10, 2023","title":"드럼 배워보기","tags":["일상"]},"rawMarkdownBody":"\r\n## 음악\r\n\r\n나는 음악 듣는 걸 좋아한다.  \r\n언제부터 좋아했는지는 모르겠지만 음악과 관련된 것이 어렸을 때부터 나를 감싸고 있었던 것 같다.  \r\n초등학교 시절에는 피아노와 바이올린을 했고 (바이올린으로는 콩쿨에서 상도 탔었다.)\r\n중학교 땐 기타를 배웠고, 고등학교 때에는 아무래도 시기가 시기이다 보니 따로 악기를 배우지는 않았다.  \r\n어렸을 때부터 음악 활동을 접해서 그런건지는 모르겠지만 악기를 배우는 데에 부담감이 없고 배우고 싶은 욕구도 주기적으로 찾아온다. 그 바탕에는 어느 정도 자신감도 있다. 나는 음치, 박치는 아니라는 자신감😎  \r\n처음 배워도 어느 정도는 잘 할 수 있을 것 같다는 자신감이 있다.\r\n\r\n## 음악 취향 변천사\r\n\r\n음악 취향에는 변천사(?)가 있는데, 중학교~고1 때에는 힙합을 많이 들었고  \r\n2011년.. 나의 최애 `이적`을 알게 되고 팬이 된 이후에는 힙합은 진짜 거의 안듣고 이적 노래와 함께 그가 좋아하는 노래를 들어본다거나 옛날 노래도 거부감없이 잘 듣게 되었던 것 같다.  \r\n밴드 음악도 굉장히 좋아한다. 고등학교 때 같은 반 친구에게 헤비메탈..까지는 아니었지만 뭔가 좀 하드한 락 노래를 추천 받아서 들었었는데 강렬한 기타와 드럼 사운드에 한 때 빠졌던 기억이 있다.\r\n\r\n## 현재\r\n\r\n그리고 지금.\r\n여전히 나의 음악 취향의 기본은 이적이고 거기에 이제 밴드 음악이 더해졌다.  \r\n요즘 굉장히 좋아하는 밴드는 `너드커넥션`이다.  \r\n내가 어떤 뮤지션을 좋아하게 될 때에는 일련의 과정이 있는 것 같다.  \r\n어떤 한 곡을 들었는데 너무 좋아서 그 뮤지션의 다른 곡들을 일단 다 재생을 시켜본다.  \r\n그렇게 한 곡씩 넘기며 듣는데 대부분이 취향에 맞으면 마음이 열린다.  \r\n그 후에 라이브 무대를 찾아본다거나 그 뮤지션에 대한 정보를 찾아보면서 더 좋아하게 되고 실제 공연을 보러 가는 단계까지 간다면 입덕 완료..  \r\n공연 보는 것 자체가 좋다면 어떤 뮤지션의 공연이든 보러갈텐데 나는 아무래도 좋아하는 뮤지션이 나오는 공연이 좋긴 좋다.\r\n\r\n## 드럼 배우기\r\n\r\n그래서!\r\n내가 좋아하는 일 찾기 과정의 일환으로 오늘 드럼을 배우고 왔다.  \r\n요즘은 너드커넥션을 굉장히 좋아하고 있어서 밴드를 하고 싶은 마음이 큰데,\r\n기타는 그래도 배워본 적도 있고 집에 기타도 있어서 언제든 칠 수 있지만 드럼은 한번도 배워본 적이 없어서 해보고 싶었다.  \r\n그래서 일단 잘 맞을지 파악해보자는 마음으로 원데이클래스를 찾아보고 신청해서 배우고 왔는데..!  \r\n굉장히 재미있었다!\r\n\r\n기타는 코드 잡는 게 어려운 것들이 꽤 많다..  \r\n물론 기타치는게 너무 좋아서 연습을 엄청 많이 하면 잘 할 수 있겠지만..\r\n암튼 어려운 게 있는데 드럼은 일단 치면 소리는 나니까ㅋㅋㅋㅋ\r\n첫 시작 난이도로는 드럼이 쉬운 것 같다.  \r\n근데 이것도 물론 오늘 처음하는거라 매우 기본적인 리듬만 한거라서 그럴 수 있다.\r\n\r\n## 마무리\r\n\r\n처음 배웠는데 어느 정도 흥미를 느껴서 한달 정도 더 배워보고 싶은 마음이 들었다.\r\n내일 당장 학원 찾아볼 수도..🤣🤣  \r\n지금 해보고 싶은건 직장인 밴드 해보기인데 포지션이 굉~장히 고민이 된다.\r\n드럼도 해보고 싶고 기타도 하고 싶고 베이스도 배워보고 싶고..  \r\n다 잘하고 싶어!!\r\n\r\n악기 다 잘 다루고 싶은 마음으로 마무리😃\r\n"},{"excerpt":"OJT 첫번째 주제인 브라우저의 동작 원리. 네이버 기술 블로그에 올라온 글을 참고해서 공부하길래 똑같은 글을 읽어봤다. 근데 이 글도 애초에 탈리 가르시엘이라는 사람의 글을 번역한 글이던데\n브라우저 내부와 수백만 줄 분량의 오픈소스 렌더링 엔진의 소스 코드를 직접 분석하여 브라우저 동작을 파악한 사람의 글이라고 한다.. 대단쓰.. 브라우저의 정의 가장 …","fields":{"slug":"/230609-브라우저 정의, 기능, 기본 구조/"},"frontmatter":{"date":"June 09, 2023","title":"브라우저 정의, 기능, 기본 구조","tags":["web","브라우저"]},"rawMarkdownBody":"\r\nOJT 첫번째 주제인 브라우저의 동작 원리.  \r\n네이버 기술 블로그에 올라온 글을 참고해서 공부하길래 똑같은 글을 읽어봤다.  \r\n근데 이 글도 애초에 탈리 가르시엘이라는 사람의 글을 번역한 글이던데\r\n브라우저 내부와 수백만 줄 분량의 오픈소스 렌더링 엔진의 소스 코드를 직접 분석하여 브라우저 동작을 파악한 사람의 글이라고 한다.. 대단쓰..\r\n\r\n## 브라우저의 정의\r\n\r\n가장 먼저 브라우저가 무엇인지부터 정의를 보자.  \r\n브라우저는 웹 서버와 쌍방향으로 통신하고 HTML 문서나 파일을 출력하는 그래픽 사용자 인터페이스(GUI) 기반의 응용 소프트웨어이다.  \r\n간단하게 말하면 웹 서버에 저장된 정보를 화면에 표시하는 소프트웨어라고 할 수 있다.\r\n우리가 사용하고 있는 크롬, 사파리, 파이어폭스, 웨일 등이 브라우저다.\r\n\r\n## 브라우저의 주요 기능\r\n\r\n주요 기능은 사용자가 선택한 자원을 서버에 요청(request)하고 서버의 응답(response)을 받아 브라우저에 표시하는 것이다.\r\n자원은 보통 HTML 문서지만 CSS, Javascript, 이미지, PDF 등 다양한 형태가 될 수 있다.\r\n\r\n과거에는 브라우저마다 서로 다르게 데이터를 해석하여 보여줬는데, 이로 인해 웹 개발자가 호환성에 어려움을 겪게 되어 최근에는 대부분의 브라우저가 웹 표준화 기구인 `W3C(World Wide Web Consortium)`의 표준 명세를 따라 구현하고 있다.\r\n\r\n브라우저의 사용자 인터페이스는 표준 명세가 없는데도 서로의 장점을 모방하며 현재의 모습이 되었다.\r\n다음은 사용자 인터페이스의 일반적 요소들이다.\r\n\r\n- URI를 입력할 수 있는 주소 표시줄\r\n- 이전 버튼과 다음 버튼\r\n- 북마크\r\n- 새로 고침 버튼과 현재 문서의 로드를 중단할 수 있는 정지 버튼\r\n- 홈 버튼\r\n\r\n## 브라우저의 기본 구조\r\n\r\n이 글이 아무래도 옛날 글이라 그 사이에 기본 구조에 뭔가가 추가되었을라나 해서 검색해봤는데\r\n다 똑같이 이 이미지를 사용하고 있다ㅋㅋㅋ 아무래도 기본 구조니까.. 그런가보다.\r\n\r\n![브라우저의 주요 구성 요소](browser.jpg)\r\n\r\n#### 사용자 인터페이스 (User Interface)\r\n\r\n주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등을 말한다. 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분이다. 사용자 인터페이스의 일반적 요소라고 말한 것들이 모두 포함된다.\r\n\r\n#### 브라우저 엔진 (Browser Engine)\r\n\r\n모든 웹 브라우저의 핵심이 되는 구성 요소로, 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어한다.\r\n사용자가 주소 표시줄에 URL을 입력하면 (사용자 인터페이스) 그걸 전달받은 브라우저 엔진이 찾아오고, 찾아온 데이터를 렌더링 엔진에 전달해 화면에 보여주도록 한다.\r\n즉, 사용자가 어떤 액션을 하는 것부터(사용자 인터페이스) 화면에 결과물로 보여주기(렌더링)까지의 과정에 관여하는 것이다.\r\n\r\n#### 렌더링 엔진 (Rendering Engine)\r\n\r\n사용자가 요청한 콘텐츠를 표시해주는 역할을 한다. HTML을 요청한다면 HTML과 CSS를 파싱하여 화면에 출력해주는 것이다.\r\n\r\n브라우저 엔진을 찾다보면 렌더링 엔진이 나와서 두 개가 같은건가 싶었다.  \r\n[이 블로그](https://codecraft.tistory.com/entry/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-2-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%97%94%EC%A7%84-%EB%93%A4%EC%97%AC%EB%8B%A4%EB%B3%B4%EA%B8%B0-Webkit)에서만 구분되어 설명해줬다.\r\n그림 상으로는 구분되어 있는데 여러 곳에서 약간 동일하게 말하고 있어서 조금 헷갈림..\r\n\r\n근데 보니까 보통 브라우저 엔진은 렌더링 엔진을 의미한다고 하는 것 같고,\r\n브라우저 엔진과 렌더링 엔진의 구분보다는 자바스크립트 엔진과의 구분이 좀 더 의미있는 구분인 것 같다.\r\n\r\n브라우저 엔진 및 렌더링 엔진에는 블링크 (Blink), 웹킷(Webkit), 게코(Gecko), 서보(Servo)등이 있다.  \r\n현재 크롬, 엣지, 웨일 등 2010년 이후 등장한 대부분의 브라우저들은 블링크를 사용하고 있다고 한다.\r\n사파리는 웹킷, 파이어폭스는 게코를 사용하고 있다고 한다.\r\n\r\n#### 통신 (Networking)\r\n\r\nHTTP(HyperText Transfer Protocol) 또는 FTP(file transfer protocol)와 같은 표준 프로토콜을 사용하여 네트워크 호출을 관리하는 역할을 한다. 통신은 플랫폼 독립적인 인터페이스이고 각 플랫폼 하부에서 실행된다.\r\n\r\n브라우저는 웹 페이지를 가져오기 위해 대부분의 웹 서버가 사용하는 `HTTP(Hyper Text Transfer Protocol)`로 통신한다.\r\nHTTP는 텍스트, 이미지 및 비디오가 웹에서 전송되는 방식을 정의하는 일종의 약속이다.\r\n\r\n#### UI 백엔드 (UI Backend)\r\n\r\n콤보 박스와 창 같은 기본적인 장치를 그려준다. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, 브라우저가 동작하고 있는 운영체제(OS)의 인터페이스를 따르는 UI를 처리한다. OS에 따라 alert이나 selectbox가 다르게 보이는 것이 UI 백엔드의 영향이다.\r\n\r\n렌더링 엔진에서 생성된 렌더 트리를 브라우저에 그리는 역할을 한다.\r\n\r\n#### 자바스크립트 엔진 (Javascript Engine)\r\n\r\n자바스크립트 코드를 해석하고 실행한다. 해석한 결과를 화면에 표시하기 위해 렌더링 엔진으로 전달한다.\r\n\r\n#### 자료 저장소 (Data Storage)\r\n\r\n자료를 저장하는 계층이다. Local Storage, Session Storage, Cookie 등을 로컬에 저장하는 영역이다. HTML5 명세에는 브라우저가 지원하는 '웹 데이터 베이스'가 정의되어 있다.\r\n\r\n## 마무리\r\n\r\n내용이 많아서 나눠서 하는걸로..! 조금씩 천천히 체하지 않게 가보자!\r\n\r\n<br />\r\n참고\r\n\r\n- [브라우저는 어떻게 동작하는가?](https://d2.naver.com/helloworld/59361)\r\n- [웹 브라우저](https://ko.wikipedia.org/wiki/%EC%9B%B9_%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80)\r\n- [[브라우저 이해하기] 2. 브라우저 엔진 들여다보기 (Webkit)](https://codecraft.tistory.com/entry/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-2-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%97%94%EC%A7%84-%EB%93%A4%EC%97%AC%EB%8B%A4%EB%B3%B4%EA%B8%B0-Webkit)\r\n- [브라우저 기본 구조와 렌더링 과정](https://velog.io/@po05360/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%EC%A1%B0%EC%99%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95)\r\n"},{"excerpt":"NestJS 9.3.0 버전부터 devTools 지원하니까 버전 업데이트 하면 좋을 것 같다는 얘기에 버전 업그레이드를 진행했다.\nNestJS에서 GraphQL을 같이 사용하고 있어 graphql의 버전도 같이 업데이트 해야하는 상황이였다. 1. 패키지 업데이트 yarn을 사용하고 있어 다음의 명령어로 업데이트를 진행하였다. yarn upgrade-int…","fields":{"slug":"/230608-NestJS 버전 업데이트/"},"frontmatter":{"date":"June 08, 2023","title":"NestJS devtools 사용하려다 GraphQLModule 설정만 바꿔본 사람?","tags":["NestJS","GraphQL"]},"rawMarkdownBody":"\r\nNestJS 9.3.0 버전부터 devTools 지원하니까 버전 업데이트 하면 좋을 것 같다는 얘기에 버전 업그레이드를 진행했다.\r\nNestJS에서 GraphQL을 같이 사용하고 있어 graphql의 버전도 같이 업데이트 해야하는 상황이였다.\r\n\r\n### 1. 패키지 업데이트\r\n\r\nyarn을 사용하고 있어 다음의 명령어로 업데이트를 진행하였다.\r\n\r\n```bash\r\nyarn upgrade-interactive\r\n```\r\n\r\nyarn upgrade-interactive 명령어는 yarn outdated와 yarn upgrade를 조합한 커맨드라고 생각하면 된다.\r\n실행하면 설치되어있는 패키지들중에서 업그레이드를 하고 싶은 패키지를 선택하여 업그레이드를 진행할 수 있다.\r\n\r\n공식 문서를 보면\r\n\r\n```typescript\r\nasync function bootstrap() {\r\n  const app = await NestFactory.create(AppModule, {\r\n    snapshot: true,\r\n  })\r\n  await app.listen(3000)\r\n}\r\n```\r\n\r\nsnapshot을 추가할 수 있어야하는데 nest의 버전이 낮으면 해당 부분에서 오류가 발생해서\r\n@nestjs/core 등 주요 패키지의 업데이트를 진행했다.\r\n\r\n### 2. @nestjs/devtools-intergration 설치\r\n\r\ndevtools를 사용하기 위해서는 위 패키지를 설치해줘야한다.\r\n여기서 조금 문제가 있었는데, 계속 위 패키지를 설치하려고 하면 사내 npm 패키지 저장소를 참조하는 것이었다..\r\n공식문서에서 말하는 것처럼 @nestjs/graphql@11 로 설치를 해도 잘 안되서 그냥 @nestjs/graphql 삭제 후 다시 설치한 다음에\r\n다시 @nestjs/devtools-intergration 설치를 시도했는데 잘 넘어갔다!\r\n\r\n### 3. graphql 관련 패키지들 업그레이드의 사이드이펙트(?)\r\n\r\n@nestjs/graphql 패키지를 `10.1.7`에서 `11.0.5`로 업데이트를 하고 나니\r\n`GraphQLModule.forRoot`의 첫번째 인자로 전달하는 options 타입인 ApolloDriverConfig가 변경이 되었는지,\r\n기존에 사용하던 cors와 debug 필드가 오류를 발생하고 있었다..\r\n어떻게 변경되어서 어떻게 사용해야하는지 열심히 찾아봐야하는 상황..!\r\n\r\n#### cors\r\n\r\ncors 관련 내용은 [nestjs/graphql 레포지토리의 issues](https://github.com/nestjs/graphql/issues/2752)에서 발견하게 되었다.\r\nNestjs에서 graphql 사용할 때에는 GraphQLModule에 따로 적어줬어야 했는데 이제는 Nestjs/common에서 제공해주는 `enableCors()`를 같이 사용하면 된다고 한다.\r\n\r\n```typescript\r\nconst app = await NestFactory.create(AppModule)\r\n\r\napp.enableCors({\r\n  origin: true,\r\n  methods: \"GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS\",\r\n  credentials: true,\r\n})\r\n```\r\n\r\n#### debug\r\n\r\n이 옵션은 요청에서 오류가 발생했을 때 response로 stacktrace를 전달해줄지에 대한 옵션이였다.\r\n클라이언트에게 stacktrace까지 제공하는 것은 일반적을 권장되지 않는다 하여 `debug: false`로 사용하고 있었는데 이 옵션이 사라져버렸다..!!\r\n아무리 검색을 해도 안나오고(ㅠㅠ) ApolloDriverConfig 타입을 봐도 못찾은 상황에서\r\n그래 없을리가 없지..! 하고 다시 천천히 ApolloDriverConfig에서 extends하고 있는 타입들을 살펴보니 눈에 띄는 필드가 하나 발견되었다.\r\n바로 `includeStacktraceInErrorResponses`!\r\n\r\n굉장히 직관적인 이름으로 변경이 되어있었다ㅋㅋㅋㅋㅋ\r\n다행히 잘 찾아내서 추가해주니 이전과 동일하게 stacktrace는 제거가 잘 되었다.. 휴..\r\n\r\n### 결말\r\n\r\n변경 후 devtools는 어떻게 사용하는거지? 싶어서 다시한번 [공식문서](https://docs.nestjs.com/devtools/overview)를 읽어보았다.\r\nsnapshot 추가하고 DevtoolsModule 추가해주고 하면 사용할 수 있는 줄 알았는데\r\nhttps://devtools.nestjs.com/ 을 들어가서 로그인을 하니까 유료였다.....\r\n그냥 쓸 수 있는 줄 알고 바꾸자고 하셨던 것 같은데 알고보니 유료ㅠㅠ\r\n결국 devtools 사용은 안하는걸로 하고 어쩌다보니 nestjs 버전 업데이트와 graphql 버전 업데이트만 진행하게 된 슬픈지만 좋은 결말..?\r\n\r\n이상 만약 우리처럼 위의 옵션을 사용하고 있다가 업데이트 하고 보니 사라져서 어떻게 해야하나 싶은 분들을 위해 남기는 글이였습니다..\r\n"},{"excerpt":"시리즈는 기초를 위한 것이기도 하지만 새로 들어오실 신입분들에게 진행될 OJT에 피드백을 드릴 수 있기 위해 나부터도 다시 공부해야 할 것 같아서 시작한다.  인터넷과 웹 먼저 인터넷과 웹에 대해 간단하게 알아보자 인터넷 ( Internet ) 인터넷이란 여러 통신망을 하나로 연결한다는 의미의 인터 네트워크( inter-network ) 라는 말에서 시작…","fields":{"slug":"/230607-인터넷과 웹/"},"frontmatter":{"date":"June 07, 2023","title":"인터넷과 웹","tags":["internet","web"]},"rawMarkdownBody":"\r\n`Back to Basics` 시리즈는 기초를 위한 것이기도 하지만 새로 들어오실 신입분들에게 진행될 OJT에 피드백을 드릴 수 있기 위해 나부터도 다시 공부해야 할 것 같아서 시작한다. <br />\r\n\r\n## 인터넷과 웹\r\n\r\n먼저 인터넷과 웹에 대해 간단하게 알아보자\r\n\r\n### 인터넷 ( Internet )\r\n\r\n인터넷이란 여러 통신망을 하나로 연결한다는 의미의 인터 네트워크( inter-network ) 라는 말에서 시작되어, 지금은 전 세계 컴퓨터들을 하나로 연결하는 거대한 컴퓨터 통신망을 의미한다.\r\n\r\n1960년, 미국에서 핵에 의해 중앙집중화된 통신이 마비될 것에 대비하여 통신망을 분산시키기 위해 구축하게 된 것이 인터넷의 시작이다.<br />\r\n1983년, TCP/IP를 공식 프로토콜로 도입하면서 현대적인 컴퓨터 네트워크의 기본 구조가 갖춰졌고, 이 때 즈음 '인터넷'이 '인터네트워크'의 약자가 아닌 고유명사 취급을 받기 시작했다고 한다.<br />\r\nweb이 나타나기 전 인터넷은 기업이나 연구소, 대학, 군대와 같은 기관에서 사용하던 통신 시스템이여서 대중적이지 않았다.\r\n\r\n### 웹 ( Web )\r\n\r\n월드 와이드 웹 ( World Wide Web ) 이란 인터넷에 연결된 사용자들이 서로의 정보를 공유할 수 있는 공간을 의미한다.\r\n줄여서 WWW나 W3라고도 부르며, 간단하게 웹(Web) 이라고 가장 많이 부른다.\r\n\r\n1989년, 팀 버너스 리 라는 사람이 문자 및 그림, 음성 등 다양한 데이터를 포함한 방대한 데이터베이스를 구축한 뒤, 이를 시각적으로 표현할 수 있는 표준 문서 형식을 규정하고 문서 속에 연결된 특정 항목은 또 다른 문서로 연결되는 정보 검색 시스템을 제시했고,\r\n이것이 '월드 와이드 웹' 이라는 세계적인 정보 공유 공간 및 하이퍼 텍스트 방식의 HTML의 개념이 등장하게 되는 계기가 되었다.\r\n\r\n1991년에는 세계 최초 홈페이지가 공개되었다. (http://info.cern.ch/)\r\n\r\n팀 버너스 리는 URL, HTTP, NEXUS(세계 최초 웹브라우저) 등의 설계 및 규격 제정에 참여하면서 웹의 아버지라고 불리게 되었다고 한다.\r\n\r\n### 인터넷과 웹의 관계\r\n\r\n인터넷과 웹은 정확히 말하면 다른 개념이다.\r\n\r\n웹은 인터넷 서비스 중 하나일 뿐이고, 웹 이외에 인터넷에서 제공하는 서비스는 `FTP`, `Email` 등이 있다.\r\n인터넷은 전 세계를 연결시켜주는 네트워크 인프라이고, 이런 인터넷을 기반으로 제공되는 서비스 중 하나가 웹인 것이다.\r\n\r\n## 인터넷의 동작 원리\r\n\r\n백엔드 로드맵에 맨 처음에 위치하는 인터넷의 동작 원리..!<br />\r\nMDN 문서를 한번 읽어보았다.\r\n\r\n### 단순한 네트워크\r\n\r\n두 개의 컴퓨터가 통신을 할 때, 다른 컴퓨터와 물리적(이더넷 케이블) 또는 무선(Wi-Fi, 블루투스)으로 연결이 되어야 한다.\r\n\r\n이런 네트워크는 원하는 만큼의 컴퓨터를 연결할 수 있지만 여러 개의 컴퓨터를 연결할 수록 복잡해진다. (필요한 물리적 자원이 늘어남)\r\n\r\n이런 문제를 해결하기 위해 사용하는 것이 `라우터`이다. 라우터는 특수한 소형 컴퓨터로 A 컴퓨터에서 B 컴퓨터에 요청을 보냈을 때, B 컴퓨터로 잘 도착하도록 해준다.\r\n따라서 각 컴퓨터는 하나의 라우터에 연결되어 서로 통신할 수 있게 된다.\r\n\r\n### 네트워크 속의 네트워크\r\n\r\n이제 좀 더 확장시켜서 수십억 대의 컴퓨터를 연결하는 상황을 생각해보자.\r\n단일 라우터는 수십억 대의 컴퓨터를 연결하는 정도로 확장할 수는 없지만\r\n라우터도 마찬가지로 컴퓨터라고 했기 때문에 서로 다른 두 대의 라우터를 연결할 수 있다.\r\n컴퓨터를 라우터에 연결하고, 라우터에서 라우터로 연결하여 무한하게 확장시킬 수 있다.\r\n\r\n네트워크의 네크워크를 구현해 하나의 통신망으로 연결하는 것이 인터넷인데, 위의 방법으로는 먼 곳의 지역과는 연결이 불가능하다.\r\n따라서 전화기 기반 시설을 사용하여 범위를 더 확장시킨다.\r\n전화기 기반 시설은 이미 서계 어느 곳과도 연결되어있기 때문에 전화 시설과 연결하는 것이고, 이를 위해서는 `모뎀`이라는 장비가 필요하다.\r\n모뎀은 네트워크의 정보를 전화 시설에서 처리할 수 있는 정보로 바꿔주고 그 반대의 경우도 마찬가지이다.\r\n\r\n이제 현재 네트워크에서 다른 네트워크로 메세지를 보내는데, 이를 위해서 네트워크를 인터넷 서비스 제공 업체(Internet Service Provider, ISP)에 연결한다.\r\n(ISP의 예시로는 KT, SK텔레콤, LG유플러스 등이 있다.)\r\nISP는 모두 함께 연결되는 몇몇 특수한 라우터를 관리하고 다른 ISP의 라우터에도 액세스할 수 잇는 회사이다.\r\n따라서 현재 네트워크의 메세지는 ISP 네트워크의 네트워크를 통해 대상 네트워크로 전달되고, 인터넷은 이러한 전체 네트워크 인프라로 구성된다.\r\n\r\n### 중간 요약\r\n\r\n컴퓨터 - 라우터 - 모뎀 - 전화시설 - ISP 이렇게 연결되어 다른 컴퓨터와 통신할 수 있게 된 것.<br />\r\n각 단계는 연결을 확장시키는 단계에서 추가되었다. (두 대의 컴퓨터 연결에서 전 세계 컴퓨터 연결로의 확장)\r\n\r\n### 컴퓨터 찾기\r\n\r\n다른 컴퓨터에 메세지를 보내려면 수신할 컴퓨터를 지정해야한다. 따라서 네트워크에 연결된 모든 컴퓨터에는 IP 주소라는 고유한 주소가 있다.\r\n컴퓨터는 IP 주소로 다른 컴퓨터를 찾는데 문제가 없지만 사람은 IP 주소를 기억하기 어렵기 때문에 '도메인' 이라는 사람이 읽을 수 있는 형태의 IP 주소 이름을 지정할 수 있다.\r\n\r\n## 마무리\r\n\r\n인터넷과 웹이라는 단어는 일상에서 굉장히 많이 사용하기도 하고 아무래도 웹 개발자로서 언젠가 분명 이런 내용을 읽은 것 같긴 한데 이번에 새삼 좀 재미있게 읽었다.<br />\r\n일단 웹이라는 개념이 팀 버너스 리 라는 한 사람의 머리에서 나와서 지금까지 꾸준히 발전해온게 진짜 뭔가 대단하고 새삼 느낌..<br />\r\nURL이랑 HTTP까지.. 어떻게 한 사람이 다..?<br />\r\n그리고 생각보다 굉장히 오래 전에 인터넷이라는 개념이 생긴 것도 신기했다. <br />1960년.. 한반도 전쟁 휴전된 게 53년인데.. 7년 뒤에 인터넷..? 그걸 지금까지도..? 이런 느낌이라 재밌었다.\r\n\r\n참고\r\n\r\n- [생활코딩](https://www.youtube.com/watch?v=pYOEy_mAMpI&list=PLuHgQVnccGMDZP7FJ_ZsUrdCGH68ppvPb&index=16)\r\n- [인터넷](https://terms.naver.com/entry.naver?docId=3573476&cid=59088&categoryId=59096)\r\n- [인터넷은 어떻게 동작하는가?](https://developer.mozilla.org/ko/docs/Learn/Common_questions/Web_mechanics/How_does_the_Internet_work)\r\n"},{"excerpt":"prologue '개발자' 라는 직업을 갖게 된 지 벌써 3년 반이라는 시간이 지났다.\n깊은 고민과 생각 없이 흘러가는대로 시작하게 되어서 그런지, 지난 시간들도 '마냥 흘려보낸 것만 같다' 라는 생각을 요즘 굉장히 많이 하고 있다. 물론 진짜로 무념무상 흘려보낸건 아니긴 하지.\n내가 맡은 일을 할 때 매 순간 많은 고민과 해결책을 찾으면서 일했고, 분명…","fields":{"slug":"/230606/"},"frontmatter":{"date":"June 06, 2023","title":"새로운 시작","tags":["일상"]},"rawMarkdownBody":"\r\n## prologue\r\n\r\n'개발자' 라는 직업을 갖게 된 지 벌써 3년 반이라는 시간이 지났다.\r\n깊은 고민과 생각 없이 흘러가는대로 시작하게 되어서 그런지, 지난 시간들도 '마냥 흘려보낸 것만 같다' 라는 생각을 요즘 굉장히 많이 하고 있다.\r\n\r\n물론 진짜로 무념무상 흘려보낸건 아니긴 하지.\r\n내가 맡은 일을 할 때 매 순간 많은 고민과 해결책을 찾으면서 일했고, 분명 처음 시작했을 때보다는 아는건 많아졌을거라 생각한다.\r\n그럼에도 지금 느끼고 있는 지난 시간들에 대한 후회는 무엇 때문일까.\r\n후회인지 회의감인지 뭔지 모를 감정에 휩쓸리고 있는게 현재 내 상태..\r\n\r\n이런 상황에서 새롭게 블로그를 만들어 글을 써보려고 하는 것은 하루하루 기록을 남기면서 나 자신에 대해서도 생각을 해보고,\r\n개발하면서 보고 배운 내용들도 정리를 해보기 위해서이다.\r\n분명 좋은 팀을 만나 3년 6개월동안 많은 것을 배웠는데 글로써 남아있는 것이 별로 없다보니 내가 무엇을 어떻게 했었는지 생각해내는 것이 어렵기도 하고,\r\n분명 일할 때 찾아보면서 적용시킨 내용들인데 오랫동안 기억에 남지 않아 같은 내용이더라도 찾아보게 되는 순간들이 있어서\r\n이젠 정말 기록을 잘 남겨보려고 한다.\r\n\r\n### 고민\r\n\r\n요즘 고민을 하고 있는건 나에게 '개발자'라는 직업이 잘 맞는건가? 하는 것인데 사실 잘 모르겠다.\r\n애초에 정말 싫다 싶었으면 학부 때 전공으로 선택을 안했을 것이고, 취업 준비할 때에도 선택지에서 제외를 시켰을 것 같은데\r\n'개발' 자체가 선택지에 없었던 적이 없긴 하다.\r\n그냥 다들 원래 무난하게 전공 살려서 취업하는거 아니야? 라고 생각하며 살았는데\r\n'개발자'라는 직업을 정말 하고 싶어서 시작하는 사람들을 보다 보니 이런 고민을 하게 되는 것 같다.\r\n(이게 지금 후회인지 회의감인지 뭔지 모를 그 감정의 원인인 듯..!)\r\n\r\n3년 6개월이라는 기간 중에 이런 생각을 한게 이번이 처음은 아니었다.\r\n뭔가 내가 무능력하다고 느껴지거나 나에 대한 확신이 없어질 때마다 이런 생각을 한 것 같긴 하다.\r\n언제인지 기억은 안나지만 한 1년 안되었을 때였던 것 같긴 한데\r\n회사에서 내가 맡은 일 중에 정말 안풀리고 어떻게 해야할지 모르겠는 일이 있었을 때,\r\n지금 와서 생각해보면 동기나 사수나 팀장님한테 솔직하게 말했어도 좋았겠다 싶지만\r\n그때의 나는 회사에서 순간순간 터지려는 눈물을 참으면서 하기도 했다.\r\n일은 잘 해결되었지만 이런 상황이 있을 때마다 나는 '내가 정말 잘하고 있는걸까?'라는 생각을 했던 것 같다.\r\n\r\n이런 생각을 진짜 요즘 매일 하게 되는데 그러다보니 좀 지쳐서..\r\n일단은 개발 공부에 시간을 투자해보자! 가 결론이 되었다.\r\n일할 때 정말 행복해 죽을 것처럼 하면 물론 좋겠지만 현재의 나는 일단 그런 사람은 아니다.\r\n그렇다고 잘하고 싶은 욕심이 없는 것도 아니다..\r\n잘하고 싶은 욕심이 없었으면 그냥 되는대로 살았을 것 같은데 그렇지는 않았다고 생각한다.\r\n나름 책도 읽고 강의도 들으면서 지식을 쌓으려고 노력도 하고\r\n새로운 기술 적용할 때도 '아.. 나는 진짜 능력이 없나.. 왜이렇게 못하냐..' 라고 생각하면서도 결국엔 하긴 하는걸 보면 그냥 평균 정도는 하지 않나 싶은..\r\n그래서 일단은 개발 공부에 들이는 시간을 늘려보면 자기 확신이 생기지 않을까 싶어 새롭게 블로그도 만든 것.\r\n\r\n개발 관련 공부도 하면서 내가 뭘 좋아하는지 찾아보는 것도 끊임없이 시도해볼 생각이다.\r\n스스로에게 질문을 했을 때 '모르겠다' 라는 답이 많은 인간이다.\r\n내가 나한테 질문하는데 왜 모르지? 나는 왜 내 자신이 제일 어렵지?\r\n이게 진짜로 모르는건지 아니면 내 자신조차 속이는건지 정말로 '모르겠다'...\r\n너무 어려워.. 어쩌다 이런 인간이 되어버린건지 모르겠지만\r\n조금 더 자신에게 솔직한 사람이 되기 위해 고민도 많이 해보려고 한다.\r\n최대한 '모르겠다'라는 답을 하지 않기 위해 노력하는게 1순위일 듯ㅠㅠ\r\n\r\n### 마무리\r\n\r\n첫 게시글이 이런.. 고민만 잔뜩 적은 글이 되어버렸지만 중요한 과정이라고 생각한다. 나 자신을 찾는 것과 개발에 시간을 투자하는 것 모두.\r\n최근에 두 분께 '다재다능한 면이 있다' 라는 말과 '잠재력이 충분히 있는 사람이다' 라는 말이 굉장히 감사했고 눈물이 날 것 같았다. 나는 이렇게 내 자신에 대해 확신이 없고 자신감이 없는데 이렇게 봐주는 사람도 있네 싶어서 왜인지 미안한 느낌도 들었다. 지금은 이런 얘길 들어도 없던 확신이 생기지 않지만 하고 싶은 게 확실해졌을 때, 이런 말도 자신있게 받아들일 수 있는 사람이 되고 싶다. 30살 이전엔 한번 찾아보자고! 이제 만나이로 바뀌니까 아직 1년 남았다!!!😂😂\r\n"}]}},"pageContext":{}},"staticQueryHashes":[]}