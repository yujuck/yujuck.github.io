{"componentChunkName":"component---src-templates-post-jsx","path":"/230613-ES6 문법 1탄/","result":{"data":{"site":{"siteMetadata":{"title":"yujuck"}},"markdownRemark":{"id":"bb80bc1a-1967-57d4-95cf-592ae1bf2c27","excerpt":"지금은 기본 중의 기본이 되어있는 ES6인데 글을 쓰는 이유는..? ES6 이후에 나온 내용들도 한번 쭉 보고 싶어서 시리즈로 만들기 위해 적어보려고 한다! ECMAScript? ES? Ecma International이 기술 규격에 따라 정의하고 있는 표준화된 스크립트 프로그래밍 언어 Javascript는 Netscape 회사의 Brendan Eich …","html":"<p>지금은 기본 중의 기본이 되어있는 ES6인데 글을 쓰는 이유는..?<br>\nES6 이후에 나온 내용들도 한번 쭉 보고 싶어서 시리즈로 만들기 위해 적어보려고 한다!</p>\n<h2>ECMAScript? ES?</h2>\n<blockquote>\n<p>Ecma International이 <code class=\"language-text\">ECMA-262</code>기술 규격에 따라 정의하고 있는 표준화된 스크립트 프로그래밍 언어</p>\n</blockquote>\n<p>Javascript는 Netscape 회사의 Brendan Eich 라는 사람에 의해 최초로 개발되었다. 그 후 Javascript의 성공에 자극을 받은 마이크로소프트는 Jscript 라는 언어를 개발하고 IE에 지원되기 시작했다.<br>\n두 스크립트가 서로 호환되지 못하는 경우가 생기게 되면서 표준화가 요구되었고, ECMA-262의 이름으로 1996년 11월부터 시작됐다.</p>\n<p><code class=\"language-text\">ES</code>는 <code class=\"language-text\">ECMAScript의 약자</code>다. 헷갈릴 수 있는 게 <code class=\"language-text\">ES6</code>는 ES016이 아니라 <code class=\"language-text\">ES2015</code>와 동일하다.\n현재는 ES6보다 더 많은 버전이 나와있는데도 최신 버전의 내용보다 ES6의 내용을 중요하게 보는 데에는 이유가 있다.</p>\n<p>먼저, ES6에 추가된 개념들이 ES6 이하 버전에서 문제가 되었던 부분들이 해결되고 많은 기능이 추가되어 현재까지도 중요한 개념들이기 때문이다. 그리고 구버전의 웹 브라우저나 레거시 코드와의 호환성 문제가 있어 대부분의 기업들이 ES6까지를 호환성의 최대치로 보고 있다고 한다.</p>\n<h3>let, const</h3>\n<p>이제는 너무 기본적인 <code class=\"language-text\">let</code> 과 <code class=\"language-text\">const</code>.</p>\n<p>블록 스코프의 변수 선언을 할 수 있게 되었다. var와의 가장 큰 차이점이 바로 함수 스코프가 아닌 블록 스코프 변수 선언이라는 것이다.</p>\n<p><code class=\"language-text\">let</code>과 <code class=\"language-text\">const</code>의 차이점은 const는 한번 초기화하면 다른 값을 정의할 수 없지만 let은 계속 값을 변경할 수 있다. 주의할 점은 const여도 객체나 배열의 요소의 변경을 막진 않는 다는 것이다.</p>\n<p>호이스팅에 대한 얘기도 무조건 나온다.</p>\n<p>var 키워드와 달리 let과 const는 변수 호이스팅이 발생하지 않는 것처럼 동작한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ReferenceError</span>\n<span class=\"token keyword\">let</span> x<span class=\"token punctuation\">;</span></code></pre></div>\n<p>var 키워드로 선언했다면 위의 상황에서 ReferenceError가 아닌 undefined가 출력되었을 것이다.<br>\n<code class=\"language-text\">var</code> 키워드 변수는 런타임 이전에 선언 단계와 초기화 단계가 <code class=\"language-text\">한번에 진행</code>되는데,<br>\n<code class=\"language-text\">let</code> 키워드 변수는 선언 단계와 초기화 단계가 <code class=\"language-text\">분리되어 진행</code>된다.<br>\n즉, 런타임 이전에 선언 단계가 먼저 실행되지만 <code class=\"language-text\">초기화 단계는 변수 선언문에 도달했을 때 실행</code>된다.</p>\n<p>초기화 단계가 실행되기 이전에 변수에 접근하려고 하면 참조 에러(ReferenceError)가 발생한다.<br>\nlet 키워드 변수는 스코프 시작 지점부터 초기화 단계가 실행되는 변수 선언문까지는 변수를 참조할 수 없는데,\n이 구간을 <code class=\"language-text\">일시적 사각지대</code>(Temporal Dead Zone: TDZ) 라고 한다.</p>\n<p>위의 특성 때문에 변수 호이스팅이 발생하지 않는 것처럼 보이지만 그렇지는 않다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 전역변수</span>\n<span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>x<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// ReferenceError</span>\n  <span class=\"token keyword\">let</span> x <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 지역변수</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>변수 호이스팅이 발생하지 않는다면 위 예제는 전역 변수 x의 값을 출력해야하는데,\n그렇지 않고 ReferenceError가 발생한다.<br>\n-> 호이스팅이 발생했기 때문에 지역 변수 x의 존재를 알고 있지만 값이 초기화 되어있지 않아서 ReferenceError가 발생</p>\n<p>자바스크립트는 ES6에서 도입된 let, const를 포함해서 모든 선언(var, let ,const, function, class 등)을 호이스팅 한다.<br>\n단, ES6에서 도입된 let, const class를 사용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작한다.</p>\n<p>참고 (ES6 관련 글 모두)</p>\n<ul>\n<li><a href=\"https://ko.wikipedia.org/wiki/ECMA%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8\">ECMA스크립트</a></li>\n<li><a href=\"https://velog.io/@krungy/ES6\">ES6</a></li>\n<li><a href=\"https://www.w3schools.com/js/js_es6.asp\">Javascript ES6</a></li>\n<li><a href=\"https://www.zerocho.com/category/ECMAScript\">ECMAScript</a></li>\n<li>모던 자바스크립트 Deep Dive</li>\n</ul>","frontmatter":{"title":"ES6(ECMAScript 6)와 let, const 키워드","date":"June 13, 2023","update":"June 13, 2023","tags":["javascript","ES6"],"series":"ECMAscript"},"fields":{"slug":"/230613-ES6 문법 1탄/","readingTime":{"minutes":5.26}}},"seriesList":{"edges":[{"node":{"id":"bb80bc1a-1967-57d4-95cf-592ae1bf2c27","fields":{"slug":"/230613-ES6 문법 1탄/"},"frontmatter":{"title":"ES6(ECMAScript 6)와 let, const 키워드"}}},{"node":{"id":"d5bc8388-fcb4-5a4f-ab35-c04b308719aa","fields":{"slug":"/230614-화살표 함수/"},"frontmatter":{"title":"화살표 함수 (ES6)"}}},{"node":{"id":"2dea0a26-ea03-5860-b50c-7fa288627b0f","fields":{"slug":"/230615-스프레드 연산자/"},"frontmatter":{"title":"스프레드 연산자 (ES6)"}}},{"node":{"id":"6c379ff9-271c-56a8-a6e1-bafa51f270b7","fields":{"slug":"/230616-for...of 반복문/"},"frontmatter":{"title":"for...of 반복문 (ES6)"}}},{"node":{"id":"1852b773-e5bb-52ee-942b-6da2a16f4a22","fields":{"slug":"/230622-Map/"},"frontmatter":{"title":"Map (ES6)"}}}]},"previous":{"fields":{"slug":"/230612-crontab 설정을 해보자/"},"frontmatter":{"title":"crontab 설정을 해보자"}},"next":{"fields":{"slug":"/230614-화살표 함수/"},"frontmatter":{"title":"화살표 함수 (ES6)"}}},"pageContext":{"id":"bb80bc1a-1967-57d4-95cf-592ae1bf2c27","series":"ECMAscript","previousPostId":"19a76f2b-107e-5006-bc09-e148927e67a1","nextPostId":"d5bc8388-fcb4-5a4f-ab35-c04b308719aa"}},"staticQueryHashes":[]}