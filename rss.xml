<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[RSS Feed of yujuck]]></title><description><![CDATA[찾아가는 과정의 기록]]></description><link>https://yujuck.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Sun, 11 Jun 2023 14:38:30 GMT</lastBuildDate><item><title><![CDATA[브라우저 렌더링]]></title><description><![CDATA[…]]></description><link>https://yujuck.github.io/230611-브라우저 렌더링/</link><guid isPermaLink="false">https://yujuck.github.io/230611-브라우저 렌더링/</guid><pubDate>Sun, 11 Jun 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;렌더링 엔진&lt;/h2&gt;
&lt;p&gt;렌더링 엔진의 기본적인 역할을 요청 받은 내용을 브라우저에 표시하는 것이다.
프론트 작업 시 브라우저마다 다르게 보이는 경우를 한번쯤 겪어보는데, 브라우저마다 사용하는 렌더링 엔진이 다르기 때문이다.&lt;/p&gt;
&lt;h2&gt;렌더링 엔진들&lt;/h2&gt;
&lt;p&gt;참고하고 있는 &lt;a href=&quot;https://d2.naver.com/helloworld/59361&quot;&gt;글&lt;/a&gt;이 아무래도 2012년 글이다보니 크롬에서 웹킷 엔진을 사용하고 있다고 하지만 현재는 전에 얘기했던 것처럼 &lt;code class=&quot;language-text&quot;&gt;블링크&lt;/code&gt;라는 엔진을 사용하고 있다. 블링크는 웹킷을 fork해서 구현된 엔진이다.&lt;br&gt;
크로미움 기반 브라우저는 블링크(Blink), 파이어폭스는 게코(Gecko), 사파리는 웹킷(Webkit)을 사용하고 있다.&lt;/p&gt;
&lt;h2&gt;동작 과정&lt;/h2&gt;
&lt;p&gt;&lt;figure class=&apos;gatsby-resp-image-figure&apos; style=&apos;margin-bottom: 16px;&apos;&gt;
    &lt;span class=&apos;gatsby-resp-image-wrapper&apos; style=&apos;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; &apos;&gt;
      &lt;a class=&apos;gatsby-resp-image-link&apos; href=&apos;/static/3226a90f76008d5b9ef77b2fe82b11dc/8e9d0/rendering_flow.jpg&apos; style=&apos;display: block&apos; target=&apos;_blank&apos; rel=&apos;noopener&apos;&gt;
    &lt;span class=&apos;gatsby-resp-image-background-image&apos; style=&quot;padding-bottom: 14.117647058823529%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAADABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAd2iQH//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAEFAn//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAQ/9oACAEBAAY/An//xAAVEAEBAAAAAAAAAAAAAAAAAAAQQf/aAAgBAQABPyGP/9oADAMBAAIAAwAAABCP/wD/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAZEAACAwEAAAAAAAAAAAAAAAAAARExkUH/2gAIAQEAAT8QShL06jT/2Q==&apos;); background-size: cover; display: block;&quot;&gt;&lt;/span&gt;
  &lt;img class=&apos;gatsby-resp-image-image&apos; alt=&apos;렌더링 엔진 동작 과정&apos; title=&apos;렌더링 엔진 동작 과정&apos; src=&apos;/static/3226a90f76008d5b9ef77b2fe82b11dc/a22ce/rendering_flow.jpg&apos; srcset=&apos;/static/3226a90f76008d5b9ef77b2fe82b11dc/0b705/rendering_flow.jpg 170w,
/static/3226a90f76008d5b9ef77b2fe82b11dc/31389/rendering_flow.jpg 340w,
/static/3226a90f76008d5b9ef77b2fe82b11dc/a22ce/rendering_flow.jpg 680w,
/static/3226a90f76008d5b9ef77b2fe82b11dc/8e9d0/rendering_flow.jpg 788w&apos; sizes=&apos;(max-width: 680px) 100vw, 680px&apos; style=&apos;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&apos; loading=&apos;lazy&apos; decoding=&apos;async&apos;&gt;
  &lt;/a&gt;
    &lt;/span&gt;
    &lt;figcaption class=&apos;gatsby-resp-image-figcaption&apos;&gt;렌더링 엔진 동작 과정&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure class=&apos;gatsby-resp-image-figure&apos; style=&apos;margin-bottom: 16px;&apos;&gt;
    &lt;span class=&apos;gatsby-resp-image-wrapper&apos; style=&apos;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 680px; &apos;&gt;
      &lt;a class=&apos;gatsby-resp-image-link&apos; href=&apos;/static/1ff99ab700ef877031a4a89c70fd15ce/dcdd0/webkit.jpg&apos; style=&apos;display: block&apos; target=&apos;_blank&apos; rel=&apos;noopener&apos;&gt;
    &lt;span class=&apos;gatsby-resp-image-background-image&apos; style=&quot;padding-bottom: 45.294117647058826%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAJABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHt26go/8QAFhABAQEAAAAAAAAAAAAAAAAAAQAg/9oACAEBAAEFAmM//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFREBAQAAAAAAAAAAAAAAAAAAARD/2gAIAQIBAT8BJ//EABYQAAMAAAAAAAAAAAAAAAAAAAEgIf/aAAgBAQAGPwI1v//EABwQAAEEAwEAAAAAAAAAAAAAAAEAESFxEDFBYf/aAAgBAQABPyE4Bh8TgNQhSHbz/9oADAMBAAIAAwAAABDQL//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABcRAQEBAQAAAAAAAAAAAAAAAAEAESH/2gAIAQIBAT8Qekcv/8QAGxABAAICAwAAAAAAAAAAAAAAAQAREDEhsfD/2gAIAQEAAT8Qt0EnlxEC4CgSJTmk70NY/9k=&apos;); background-size: cover; display: block;&quot;&gt;&lt;/span&gt;
  &lt;img class=&apos;gatsby-resp-image-image&apos; alt=&apos;웹킷 동작 과정&apos; title=&apos;웹킷 동작 과정&apos; src=&apos;/static/1ff99ab700ef877031a4a89c70fd15ce/a22ce/webkit.jpg&apos; srcset=&apos;/static/1ff99ab700ef877031a4a89c70fd15ce/0b705/webkit.jpg 170w,
/static/1ff99ab700ef877031a4a89c70fd15ce/31389/webkit.jpg 340w,
/static/1ff99ab700ef877031a4a89c70fd15ce/a22ce/webkit.jpg 680w,
/static/1ff99ab700ef877031a4a89c70fd15ce/dcdd0/webkit.jpg 708w&apos; sizes=&apos;(max-width: 680px) 100vw, 680px&apos; style=&apos;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&apos; loading=&apos;lazy&apos; decoding=&apos;async&apos;&gt;
  &lt;/a&gt;
    &lt;/span&gt;
    &lt;figcaption class=&apos;gatsby-resp-image-figcaption&apos;&gt;웹킷 동작 과정&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;렌더링 엔진은 통신으로부터 요청한 문서의 내용을 얻는 것으로 시작한다.&lt;/p&gt;
&lt;h3&gt;파싱과 트리 구축&lt;/h3&gt;
&lt;h4&gt;HTML 파싱&lt;/h4&gt;
&lt;p&gt;렌더링 엔진은 통신으로부터 얻어온 &lt;code class=&quot;language-text&quot;&gt;HTML 문서&lt;/code&gt;를 파싱하여 브라우저가 이해할 수 있는 &lt;code class=&quot;language-text&quot;&gt;DOM(Document Object Model)&lt;/code&gt;으로 변환시킨다. HTML을 파싱할 때에는 HTML파서로 파싱을 하고, 이것은 HTML 마크업을 파싱 트리로 변환해준다. 브라우저가 HTML 파싱을 위해 별도의 HTML파서를 생성하는 것에는 이유가 있다.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HTML의 너그러운 속성&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;HTML에서 시작 또는 종료 태그 등을 생략하는 경우가 있다.
HTML은 암묵적으로 태그에 대한 생략이 가능하다. 이런 부분이 HTML이 유연한 문법을 가지고 있다는 것을 보여준다.&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;HTML에 대한 브라우저의 관용&lt;/li&gt;
&lt;li&gt;변경에 의한 재파싱, 스크립트 태그는 토큰을 추가할 수 있어 파싱이 수정될 수 있음&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;이런 이유들로 일반적인 파서로는 HTML을 파싱할 수 없어 HTML 파서로 파싱을 한다.
파싱 알고리즘은 토큰화와 트리 구축 단계로 되어있다.&lt;br&gt;
토큰화는 입력값을 토큰으로 파싱하는 과정을 말하는데, HTML에서 토큰은 시작 태그, 종료 태그, 속성 이름과 속성 값이다. 토큰을 인지해 트리 생성자로 넘기고 다음 토큰을 확인하기 위해 다음 문자를 확인한다.&lt;/p&gt;
&lt;p&gt;토큰을 읽어 트리를 구축하는 파싱 단계를 거치면 브라우저는 문서(Document)와 상호작용할 수 있게 되고 문서 파싱 이후에 실행되어야 하는 지연 모드 스크립트를 파싱한다. 이때 load 이벤트가 발생한다.&lt;/p&gt;
&lt;h4&gt;CSS 파싱&lt;/h4&gt;
&lt;p&gt;브라우저는 DOM을 생성하는 동안 css를 불러오는 link를 만나면 즉시 해당 리소스에 대한 요청을 보낸다. css도 브라우저가 이해하고 처리할 수 있도록 변환해줘야 하기 때문에 HTML과 같은 방식으로 파싱하여 CSSOM을 생성한다.&lt;/p&gt;
&lt;h4&gt;스크립트의 진행 순서&lt;/h4&gt;
&lt;p&gt;script 태그를 만나면 script를 먼저 파싱하고 실행하게 되어있어 스크립트가 실행되는 동안 문서의 파싱은 중단된다.
src 속성이 있는 외부 스크립트 태그를 만났을 때도 마찬가지이다.&lt;br&gt;
이런 동작 방식은 스크립트에서 스크립트 아래에 있는 DOM 요소에 접근할 수 없게 하고, 용량이 큰 스크립트가 있는 경우에는 스크립트가 실행될 때까지 페이지를 볼 수 없게 된다.&lt;br&gt;
그래서 &lt;code class=&quot;language-text&quot;&gt;defer&lt;/code&gt;라는 속성을 사용하면 문서 파싱이 중단되지 않고 파싱이 완료된 이후에 스크립트가 실행될 수 있다.&lt;br&gt;
비동기로 처리할 수 있는 &lt;code class=&quot;language-text&quot;&gt;async&lt;/code&gt; 속성도 추가되어 별도의 맥락에 의해 파싱되고 실행될 수 있게 되었다.&lt;/p&gt;
&lt;p&gt;⭐ defer, async ⭐&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;defer&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;defer 속성은 외부 스크립트에만 유효하다. script에 src가 없으면 defer 속성이 무시된다.&lt;br&gt;
브라우저는 defer 속성이 있는 스크립트를 백그라운드에서 다운로드 한다. 따라서 defer 스크립트를 다운로드하는 중에도 HTML의 파싱을 중단하지 않는다. defer 스크립트의 실행은 페이지가 파싱이 끝나고 렌더링을 시작할 때까지(페이지 구성이 끝날 때까지) 기다린 후 실행된다.&lt;/p&gt;
&lt;p&gt;DOM이 준비된 후에 실행되긴 하지만 DOMContentLoaded 이벤트 발생 전에 실행된다.&lt;br&gt;
defer 스크립트는 HTML에 추가된 순으로 실행이 되기 때문에 defer 속성이 정의된 script 태그가 여러개일 경우 먼저 정의된 script가 실행이 된 후에 그 다음 defer 스크립트가 실행이 된다.&lt;br&gt;
다운로드는 병렬적으로 진행이 되지만 실행 자체는 추가된 순서대로 진행이 된다.&lt;/p&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;async&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;async 속성이 있는 스크립트는 페이지와 독립적으로 동작한다.
다운로드는 defer와 마찬가지로 백그라운드에서 한다. 따라서 async 스크립트 다운로드를 기다리지 않고 HTML 페이지의 처리가 진행된다. 하지만 async 스크립트의 실행 중에는 HTML 파싱이 멈춘다.&lt;/p&gt;
&lt;p&gt;또 다른 점은 DOMContentLoaded 이벤트와 async 스크립트는 서로를 기다리지 않는다는 것이다.
defer 스크립트가 끝난 후에 DOMContentLoaded이벤트가 발생했던 것과 달리&lt;br&gt;
async 스크립트는 DOMContentLoaded의 전후로 실행될 수 있다.&lt;/p&gt;
&lt;p&gt;다른 스크립트 또한 async 스크립트를 기다리지 않고 async 스크립트 또한 다른 스크립트를 기다리지 않는다.
그렇기 때문에 async 스크립트가 여러개 있는 경우에는 실행 순서가 제각각 다르다. 실행은 다운로드가 끝난 스크립트 순서대로 진행이 된다.&lt;/p&gt;
&lt;p&gt;이러한 특징으로, async는 스크립트가 독립적인 역할을 할 때 유용하다.&lt;/p&gt;
&lt;h3&gt;렌더 트리 구축&lt;/h3&gt;
&lt;p&gt;DOM 트리와 CSSOM을 결합하여 렌더 트리가 구축된다.
렌더 트리는 실제로 화면에 표시되는 요소만 추려서 트리 형태로 만들고 표시해야할 순서대로 그려낼 수 있도록 트리를 생성한다. 이 단계를 Attachment 라고 한다.&lt;/p&gt;
&lt;p&gt;렌더 트리는 시각적 속성이 있는 사각형을 포함하고 있다. 너비, 높이, 위치와 같은 기하학적 정보도 포함되어 있다.&lt;/p&gt;
&lt;h4&gt;DOM 트리와 렌더 트리&lt;/h4&gt;
&lt;p&gt;이 둘은 1:1로 대응하는 관계가 아니다. 위에서 말한 것처럼 렌더 트리에는 실제 표시되는 요소만 있기 때문에 head와 같은 비시각적 요소는 포함되지 않는다. 또한 &lt;code class=&quot;language-text&quot;&gt;display: none&lt;/code&gt;이 할당되어있는 요소도 렌더 트리에 포함되지 않는다.&lt;/p&gt;
&lt;p&gt;여러 개의 DOM 요소와 대응하는 렌더 트리 요소도 있기도 하고(ex. select)&lt;br&gt;
서로 동일한 위치에 있지 않는 경우도 있다. (float, position 속성 사용 요소)&lt;/p&gt;
&lt;p&gt;렌더 트리 생성이 끝나면 각 노드가 화면의 정확한 위치에 표시되는 &lt;code class=&quot;language-text&quot;&gt;배치&lt;/code&gt;가 시작되며, UI 백엔드에서 렌더 트리의 각 노드를 가로지르며 형상을 만들어내는 &lt;code class=&quot;language-text&quot;&gt;그리기&lt;/code&gt; 과정으로 이어진다.&lt;/p&gt;
&lt;p&gt;위의 과정들은 점진적으로 진행이 된다. 모든 HTML을 파싱할 때까지 기다리지 않고 렌더 트리 배치와 그리기 과정을 시작한다.&lt;/p&gt;
&lt;p&gt;⭐ display: none 과 visibility: hidden&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;display: none&lt;/code&gt;은 요소가 보이지 않고 렌더 트리에서도 요소룰 제거하지만
&lt;code class=&quot;language-text&quot;&gt;visibility: hidden&lt;/code&gt;는 요소를 보이지 않게 하지만 공간을 차지하고 있어 비어있는 사각형으로 렌더링 된다.&lt;/p&gt;
&lt;h3&gt;렌더 트리 배치&lt;/h3&gt;
&lt;p&gt;렌더 트리가 생성되면 브라우저의 뷰포트 내에서 각 노드들의 정확한 위치와 크기를 계산한다. 이 때 %, vh, vw와 같이 상대적인 위치, 크기 속성은 모두 실제 그려지는 px 단위로 변환되며 이 과정을 &lt;code class=&quot;language-text&quot;&gt;Layout&lt;/code&gt;(배치)이라고 한다.&lt;/p&gt;
&lt;p&gt;배치는 왼쪽에서 오른쪽, 위에서 아래로 진행된다. DOM 트리, CSSOM 트리가 변경될 때마다 재구성되는데 이걸 Reflow라고 말한다.DOM 요소의 기하학적 속성이 변경되거나, 화면의 크기가 변경될 때 reflow된다.&lt;/p&gt;
&lt;p&gt;요소 하나의 변경이 주변 요소들의 위치와 크기에 영향을 주고, 그 주변 요소들이 또 다른 요소들에게도 영향을 미치게 되어 결국에는 DOM 트리 전체에 대한 계산 작업이 발생하게 된다.&lt;br&gt;
그러면 렌더 트리가 다시 업데이트가 되고 그리기 단계까지 진행이 되면서 화면에 표시가 된다. 작업 비용이 크다는 것을 알 수 있다.&lt;/p&gt;
&lt;p&gt;Reflow가 일어나는 대표적 예는 다음과 같다&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;브라우저 리사이징 (뷰포트 크기 변경)&lt;/li&gt;
&lt;li&gt;노드의 추가 및 제거&lt;/li&gt;
&lt;li&gt;요소의 위치, 크기 변경&lt;/li&gt;
&lt;li&gt;폰트 변경과 이미지 크기 변경&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;렌더 트리 그리기&lt;/h3&gt;
&lt;p&gt;렌더 트리의 배치가 끝나면 실제 화면을 그린다. 그리기 단계에서는 화면에 내용을 표시하기 위한 렌더 트리가 탐색되고 렌더러의 &lt;code class=&quot;language-text&quot;&gt;paint&lt;/code&gt; 메서드가 호출된다. 그리기는 UI 기반의 구성 요소를 사용한다.&lt;/p&gt;
&lt;p&gt;처리해야하는 스타일이 복잡할 수록 paint 단계의 소요시간이 길어지게 되는데, background-color, color 등의 단색 처리는 속도가 빠르지만 그라데이션이나 그림자 효과 등의 스타일은 paint 단계의 소요시간이 비교적 더 오래 소요된다.&lt;/p&gt;
&lt;p&gt;Reflow가 일어나면 실제 화면에 표시되기 위해서는 paint 과정도 다시 수행이 되어야 하고, 이 과정을 &lt;code class=&quot;language-text&quot;&gt;Repaint&lt;/code&gt;라고 한다.
Reflow가 일어났을 때만 Repaint가 실행되는건 아니고 기하학적 변화가 아닌 이미지, 색상과 같은 요소들이 변할 경우, layout 부분을 생략하고 (계산 생략) paint 작업이 진행된다. (ex. background-color, opacity 변경)&lt;/p&gt;
&lt;p&gt;참고&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://d2.naver.com/helloworld/59361&quot;&gt;브라우저는 어떻게 동작하는가?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Web/API/Document_Object_Model/Introduction&quot;&gt;DOM 소개&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ko.javascript.info/script-async-defer&quot;&gt;defer, async 스크립트&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ppoote.tistory.com/172&quot;&gt;브라우저 렌더링 과정&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[드럼 배워보기]]></title><description><![CDATA[…]]></description><link>https://yujuck.github.io/230610-드럼 배워보기/</link><guid isPermaLink="false">https://yujuck.github.io/230610-드럼 배워보기/</guid><pubDate>Sat, 10 Jun 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;음악&lt;/h2&gt;
&lt;p&gt;나는 음악 듣는 걸 좋아한다.&lt;br&gt;
언제부터 좋아했는지는 모르겠지만 음악과 관련된 것이 어렸을 때부터 나를 감싸고 있었던 것 같다.&lt;br&gt;
초등학교 시절에는 피아노와 바이올린을 했고 (바이올린으로는 콩쿨에서 상도 탔었다.)
중학교 땐 기타를 배웠고, 고등학교 때에는 아무래도 시기가 시기이다 보니 따로 악기를 배우지는 않았다.&lt;br&gt;
어렸을 때부터 음악 활동을 접해서 그런건지는 모르겠지만 악기를 배우는 데에 부담감이 없고 배우고 싶은 욕구도 주기적으로 찾아온다. 그 바탕에는 어느 정도 자신감도 있다. 나는 음치, 박치는 아니라는 자신감😎&lt;br&gt;
처음 배워도 어느 정도는 잘 할 수 있을 것 같다는 자신감이 있다.&lt;/p&gt;
&lt;h2&gt;음악 취향 변천사&lt;/h2&gt;
&lt;p&gt;음악 취향에는 변천사(?)가 있는데, 중학교~고1 때에는 힙합을 많이 들었고&lt;br&gt;
2011년.. 나의 최애 &lt;code class=&quot;language-text&quot;&gt;이적&lt;/code&gt;을 알게 되고 팬이 된 이후에는 힙합은 진짜 거의 안듣고 이적 노래와 함께 그가 좋아하는 노래를 들어본다거나 옛날 노래도 거부감없이 잘 듣게 되었던 것 같다.&lt;br&gt;
밴드 음악도 굉장히 좋아한다. 고등학교 때 같은 반 친구에게 헤비메탈..까지는 아니었지만 뭔가 좀 하드한 락 노래를 추천 받아서 들었었는데 강렬한 기타와 드럼 사운드에 한 때 빠졌던 기억이 있다.&lt;/p&gt;
&lt;h2&gt;현재&lt;/h2&gt;
&lt;p&gt;그리고 지금.
여전히 나의 음악 취향의 기본은 이적이고 거기에 이제 밴드 음악이 더해졌다.&lt;br&gt;
요즘 굉장히 좋아하는 밴드는 &lt;code class=&quot;language-text&quot;&gt;너드커넥션&lt;/code&gt;이다.&lt;br&gt;
내가 어떤 뮤지션을 좋아하게 될 때에는 일련의 과정이 있는 것 같다.&lt;br&gt;
어떤 한 곡을 들었는데 너무 좋아서 그 뮤지션의 다른 곡들을 일단 다 재생을 시켜본다.&lt;br&gt;
그렇게 한 곡씩 넘기며 듣는데 대부분이 취향에 맞으면 마음이 열린다.&lt;br&gt;
그 후에 라이브 무대를 찾아본다거나 그 뮤지션에 대한 정보를 찾아보면서 더 좋아하게 되고 실제 공연을 보러 가는 단계까지 간다면 입덕 완료..&lt;br&gt;
공연 보는 것 자체가 좋다면 어떤 뮤지션의 공연이든 보러갈텐데 나는 아무래도 좋아하는 뮤지션이 나오는 공연이 좋긴 좋다.&lt;/p&gt;
&lt;h2&gt;드럼 배우기&lt;/h2&gt;
&lt;p&gt;그래서!
내가 좋아하는 일 찾기 과정의 일환으로 오늘 드럼을 배우고 왔다.&lt;br&gt;
요즘은 너드커넥션을 굉장히 좋아하고 있어서 밴드를 하고 싶은 마음이 큰데,
기타는 그래도 배워본 적도 있고 집에 기타도 있어서 언제든 칠 수 있지만 드럼은 한번도 배워본 적이 없어서 해보고 싶었다.&lt;br&gt;
그래서 일단 잘 맞을지 파악해보자는 마음으로 원데이클래스를 찾아보고 신청해서 배우고 왔는데..!&lt;br&gt;
굉장히 재미있었다!&lt;/p&gt;
&lt;p&gt;기타는 코드 잡는 게 어려운 것들이 꽤 많다..&lt;br&gt;
물론 기타치는게 너무 좋아서 연습을 엄청 많이 하면 잘 할 수 있겠지만..
암튼 어려운 게 있는데 드럼은 일단 치면 소리는 나니까ㅋㅋㅋㅋ
첫 시작 난이도로는 드럼이 쉬운 것 같다.&lt;br&gt;
근데 이것도 물론 오늘 처음하는거라 매우 기본적인 리듬만 한거라서 그럴 수 있다.&lt;/p&gt;
&lt;h2&gt;마무리&lt;/h2&gt;
&lt;p&gt;처음 배웠는데 어느 정도 흥미를 느껴서 한달 정도 더 배워보고 싶은 마음이 들었다.
내일 당장 학원 찾아볼 수도..🤣🤣&lt;br&gt;
지금 해보고 싶은건 직장인 밴드 해보기인데 포지션이 굉~장히 고민이 된다.
드럼도 해보고 싶고 기타도 하고 싶고 베이스도 배워보고 싶고..&lt;br&gt;
다 잘하고 싶어!!&lt;/p&gt;
&lt;p&gt;악기 다 잘 다루고 싶은 마음으로 마무리😃&lt;/p&gt;</content:encoded></item><item><title><![CDATA[브라우저 정의, 기능, 기본 구조]]></title><description><![CDATA[OJT…]]></description><link>https://yujuck.github.io/230609-브라우저 정의, 기능, 기본 구조/</link><guid isPermaLink="false">https://yujuck.github.io/230609-브라우저 정의, 기능, 기본 구조/</guid><pubDate>Fri, 09 Jun 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;OJT 첫번째 주제인 브라우저의 동작 원리.&lt;br&gt;
네이버 기술 블로그에 올라온 글을 참고해서 공부하길래 똑같은 글을 읽어봤다.&lt;br&gt;
근데 이 글도 애초에 탈리 가르시엘이라는 사람의 글을 번역한 글이던데
브라우저 내부와 수백만 줄 분량의 오픈소스 렌더링 엔진의 소스 코드를 직접 분석하여 브라우저 동작을 파악한 사람의 글이라고 한다.. 대단쓰..&lt;/p&gt;
&lt;h2&gt;브라우저의 정의&lt;/h2&gt;
&lt;p&gt;가장 먼저 브라우저가 무엇인지부터 정의를 보자.&lt;br&gt;
브라우저는 웹 서버와 쌍방향으로 통신하고 HTML 문서나 파일을 출력하는 그래픽 사용자 인터페이스(GUI) 기반의 응용 소프트웨어이다.&lt;br&gt;
간단하게 말하면 웹 서버에 저장된 정보를 화면에 표시하는 소프트웨어라고 할 수 있다.
우리가 사용하고 있는 크롬, 사파리, 파이어폭스, 웨일 등이 브라우저다.&lt;/p&gt;
&lt;h2&gt;브라우저의 주요 기능&lt;/h2&gt;
&lt;p&gt;주요 기능은 사용자가 선택한 자원을 서버에 요청(request)하고 서버의 응답(response)을 받아 브라우저에 표시하는 것이다.
자원은 보통 HTML 문서지만 CSS, Javascript, 이미지, PDF 등 다양한 형태가 될 수 있다.&lt;/p&gt;
&lt;p&gt;과거에는 브라우저마다 서로 다르게 데이터를 해석하여 보여줬는데, 이로 인해 웹 개발자가 호환성에 어려움을 겪게 되어 최근에는 대부분의 브라우저가 웹 표준화 기구인 &lt;code class=&quot;language-text&quot;&gt;W3C(World Wide Web Consortium)&lt;/code&gt;의 표준 명세를 따라 구현하고 있다.&lt;/p&gt;
&lt;p&gt;브라우저의 사용자 인터페이스는 표준 명세가 없는데도 서로의 장점을 모방하며 현재의 모습이 되었다.
다음은 사용자 인터페이스의 일반적 요소들이다.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;URI를 입력할 수 있는 주소 표시줄&lt;/li&gt;
&lt;li&gt;이전 버튼과 다음 버튼&lt;/li&gt;
&lt;li&gt;북마크&lt;/li&gt;
&lt;li&gt;새로 고침 버튼과 현재 문서의 로드를 중단할 수 있는 정지 버튼&lt;/li&gt;
&lt;li&gt;홈 버튼&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;브라우저의 기본 구조&lt;/h2&gt;
&lt;p&gt;이 글이 아무래도 옛날 글이라 그 사이에 기본 구조에 뭔가가 추가되었을라나 해서 검색해봤는데
다 똑같이 이 이미지를 사용하고 있다ㅋㅋㅋ 아무래도 기본 구조니까.. 그런가보다.&lt;/p&gt;
&lt;p&gt;&lt;figure class=&apos;gatsby-resp-image-figure&apos; style=&apos;margin-bottom: 16px;&apos;&gt;
    &lt;span class=&apos;gatsby-resp-image-wrapper&apos; style=&apos;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 526px; &apos;&gt;
      &lt;a class=&apos;gatsby-resp-image-link&apos; href=&apos;/static/91390006914143cd057da02e65a4ef15/d258d/browser.jpg&apos; style=&apos;display: block&apos; target=&apos;_blank&apos; rel=&apos;noopener&apos;&gt;
    &lt;span class=&apos;gatsby-resp-image-background-image&apos; style=&quot;padding-bottom: 67.05882352941177%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDAQX/xAAWAQEBAQAAAAAAAAAAAAAAAAAAAQL/2gAMAwEAAhADEAAAAe2uzKjGb//EABcQAQEBAQAAAAAAAAAAAAAAAAEAEBH/2gAIAQEAAQUCYMbuf//EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAEDAQE/Aaf/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAYEAADAQEAAAAAAAAAAAAAAAAAARAh4f/aAAgBAQAGPwI7GLJ//8QAGhAAAgMBAQAAAAAAAAAAAAAAAAERITFx0f/aAAgBAQABPyFbfphoWvpGGhFEyQjT/9oADAMBAAIAAwAAABB7P//EABcRAAMBAAAAAAAAAAAAAAAAAAABEVH/2gAIAQMBAT8QrSo//8QAFhEBAQEAAAAAAAAAAAAAAAAAAQAR/9oACAECAQE/EDE2Bv/EABwQAQACAwADAAAAAAAAAAAAAAEAESExQVFhof/aAAgBAQABPxAls/MDTr2jXbhR2DodLmPFfBCrltuf/9k=&apos;); background-size: cover; display: block;&quot;&gt;&lt;/span&gt;
  &lt;img class=&apos;gatsby-resp-image-image&apos; alt=&apos;브라우저의 주요 구성 요소&apos; title=&apos;브라우저의 주요 구성 요소&apos; src=&apos;/static/91390006914143cd057da02e65a4ef15/d258d/browser.jpg&apos; srcset=&apos;/static/91390006914143cd057da02e65a4ef15/0b705/browser.jpg 170w,
/static/91390006914143cd057da02e65a4ef15/31389/browser.jpg 340w,
/static/91390006914143cd057da02e65a4ef15/d258d/browser.jpg 526w&apos; sizes=&apos;(max-width: 526px) 100vw, 526px&apos; style=&apos;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&apos; loading=&apos;lazy&apos; decoding=&apos;async&apos;&gt;
  &lt;/a&gt;
    &lt;/span&gt;
    &lt;figcaption class=&apos;gatsby-resp-image-figcaption&apos;&gt;브라우저의 주요 구성 요소&lt;/figcaption&gt;
  &lt;/figure&gt;&lt;/p&gt;
&lt;h4&gt;사용자 인터페이스 (User Interface)&lt;/h4&gt;
&lt;p&gt;주소 표시줄, 이전/다음 버튼, 북마크 메뉴 등을 말한다. 요청한 페이지를 보여주는 창을 제외한 나머지 모든 부분이다. 사용자 인터페이스의 일반적 요소라고 말한 것들이 모두 포함된다.&lt;/p&gt;
&lt;h4&gt;브라우저 엔진 (Browser Engine)&lt;/h4&gt;
&lt;p&gt;모든 웹 브라우저의 핵심이 되는 구성 요소로, 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어한다.
사용자가 주소 표시줄에 URL을 입력하면 (사용자 인터페이스) 그걸 전달받은 브라우저 엔진이 찾아오고, 찾아온 데이터를 렌더링 엔진에 전달해 화면에 보여주도록 한다.
즉, 사용자가 어떤 액션을 하는 것부터(사용자 인터페이스) 화면에 결과물로 보여주기(렌더링)까지의 과정에 관여하는 것이다.&lt;/p&gt;
&lt;h4&gt;렌더링 엔진 (Rendering Engine)&lt;/h4&gt;
&lt;p&gt;사용자가 요청한 콘텐츠를 표시해주는 역할을 한다. HTML을 요청한다면 HTML과 CSS를 파싱하여 화면에 출력해주는 것이다.&lt;/p&gt;
&lt;p&gt;브라우저 엔진을 찾다보면 렌더링 엔진이 나와서 두 개가 같은건가 싶었다.&lt;br&gt;
&lt;a href=&quot;https://codecraft.tistory.com/entry/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-2-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%97%94%EC%A7%84-%EB%93%A4%EC%97%AC%EB%8B%A4%EB%B3%B4%EA%B8%B0-Webkit&quot;&gt;이 블로그&lt;/a&gt;에서만 구분되어 설명해줬다.
그림 상으로는 구분되어 있는데 여러 곳에서 약간 동일하게 말하고 있어서 조금 헷갈림..&lt;/p&gt;
&lt;p&gt;근데 보니까 보통 브라우저 엔진은 렌더링 엔진을 의미한다고 하는 것 같고,
브라우저 엔진과 렌더링 엔진의 구분보다는 자바스크립트 엔진과의 구분이 좀 더 의미있는 구분인 것 같다.&lt;/p&gt;
&lt;p&gt;브라우저 엔진 및 렌더링 엔진에는 블링크 (Blink), 웹킷(Webkit), 게코(Gecko), 서보(Servo)등이 있다.&lt;br&gt;
현재 크롬, 엣지, 웨일 등 2010년 이후 등장한 대부분의 브라우저들은 블링크를 사용하고 있다고 한다.
사파리는 웹킷, 파이어폭스는 게코를 사용하고 있다고 한다.&lt;/p&gt;
&lt;h4&gt;통신 (Networking)&lt;/h4&gt;
&lt;p&gt;HTTP(HyperText Transfer Protocol) 또는 FTP(file transfer protocol)와 같은 표준 프로토콜을 사용하여 네트워크 호출을 관리하는 역할을 한다. 통신은 플랫폼 독립적인 인터페이스이고 각 플랫폼 하부에서 실행된다.&lt;/p&gt;
&lt;p&gt;브라우저는 웹 페이지를 가져오기 위해 대부분의 웹 서버가 사용하는 &lt;code class=&quot;language-text&quot;&gt;HTTP(Hyper Text Transfer Protocol)&lt;/code&gt;로 통신한다.
HTTP는 텍스트, 이미지 및 비디오가 웹에서 전송되는 방식을 정의하는 일종의 약속이다.&lt;/p&gt;
&lt;h4&gt;UI 백엔드 (UI Backend)&lt;/h4&gt;
&lt;p&gt;콤보 박스와 창 같은 기본적인 장치를 그려준다. 플랫폼에서 명시하지 않은 일반적인 인터페이스로서, 브라우저가 동작하고 있는 운영체제(OS)의 인터페이스를 따르는 UI를 처리한다. OS에 따라 alert이나 selectbox가 다르게 보이는 것이 UI 백엔드의 영향이다.&lt;/p&gt;
&lt;p&gt;렌더링 엔진에서 생성된 렌더 트리를 브라우저에 그리는 역할을 한다.&lt;/p&gt;
&lt;h4&gt;자바스크립트 엔진 (Javascript Engine)&lt;/h4&gt;
&lt;p&gt;자바스크립트 코드를 해석하고 실행한다. 해석한 결과를 화면에 표시하기 위해 렌더링 엔진으로 전달한다.&lt;/p&gt;
&lt;h4&gt;자료 저장소 (Data Storage)&lt;/h4&gt;
&lt;p&gt;자료를 저장하는 계층이다. Local Storage, Session Storage, Cookie 등을 로컬에 저장하는 영역이다. HTML5 명세에는 브라우저가 지원하는 &apos;웹 데이터 베이스&apos;가 정의되어 있다.&lt;/p&gt;
&lt;h2&gt;마무리&lt;/h2&gt;
&lt;p&gt;내용이 많아서 나눠서 하는걸로..! 조금씩 천천히 체하지 않게 가보자!&lt;/p&gt;
&lt;br /&gt;
참고
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://d2.naver.com/helloworld/59361&quot;&gt;브라우저는 어떻게 동작하는가?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ko.wikipedia.org/wiki/%EC%9B%B9_%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80&quot;&gt;웹 브라우저&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://codecraft.tistory.com/entry/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0-2-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%97%94%EC%A7%84-%EB%93%A4%EC%97%AC%EB%8B%A4%EB%B3%B4%EA%B8%B0-Webkit&quot;&gt;[브라우저 이해하기] 2. 브라우저 엔진 들여다보기 (Webkit)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://velog.io/@po05360/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EA%B8%B0%EB%B3%B8-%EA%B5%AC%EC%A1%B0%EC%99%80-%EB%A0%8C%EB%8D%94%EB%A7%81-%EA%B3%BC%EC%A0%95&quot;&gt;브라우저 기본 구조와 렌더링 과정&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[NestJS devtools 사용하려다 GraphQLModule 설정만 바꿔본 사람?]]></title><description><![CDATA[NestJS 9.3.0 버전부터 devTools 지원하니까 버전 업데이트 하면 좋을 것 같다는 얘기에 버전 업그레이드를 진행했다.
NestJS에서 GraphQL을 같이 사용하고 있어 graphql의 버전도 같이 업데이트 해야하는 상황이였다.…]]></description><link>https://yujuck.github.io/230608-NestJS 버전 업데이트/</link><guid isPermaLink="false">https://yujuck.github.io/230608-NestJS 버전 업데이트/</guid><pubDate>Thu, 08 Jun 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;NestJS 9.3.0 버전부터 devTools 지원하니까 버전 업데이트 하면 좋을 것 같다는 얘기에 버전 업그레이드를 진행했다.
NestJS에서 GraphQL을 같이 사용하고 있어 graphql의 버전도 같이 업데이트 해야하는 상황이였다.&lt;/p&gt;
&lt;h3&gt;1. 패키지 업데이트&lt;/h3&gt;
&lt;p&gt;yarn을 사용하고 있어 다음의 명령어로 업데이트를 진행하였다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;bash&quot;&gt;&lt;pre class=&quot;language-bash&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;&lt;span class=&quot;token function&quot;&gt;yarn&lt;/span&gt; upgrade-interactive&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;yarn upgrade-interactive 명령어는 yarn outdated와 yarn upgrade를 조합한 커맨드라고 생각하면 된다.
실행하면 설치되어있는 패키지들중에서 업그레이드를 하고 싶은 패키지를 선택하여 업그레이드를 진행할 수 있다.&lt;/p&gt;
&lt;p&gt;공식 문서를 보면&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;typescript&quot;&gt;&lt;pre class=&quot;language-typescript&quot;&gt;&lt;code class=&quot;language-typescript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;bootstrap&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; app &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; NestFactory&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;AppModule&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    snapshot&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; app&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;listen&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;3000&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;snapshot을 추가할 수 있어야하는데 nest의 버전이 낮으면 해당 부분에서 오류가 발생해서
@nestjs/core 등 주요 패키지의 업데이트를 진행했다.&lt;/p&gt;
&lt;h3&gt;2. @nestjs/devtools-intergration 설치&lt;/h3&gt;
&lt;p&gt;devtools를 사용하기 위해서는 위 패키지를 설치해줘야한다.
여기서 조금 문제가 있었는데, 계속 위 패키지를 설치하려고 하면 사내 npm 패키지 저장소를 참조하는 것이었다..
공식문서에서 말하는 것처럼 @nestjs/graphql@11 로 설치를 해도 잘 안되서 그냥 @nestjs/graphql 삭제 후 다시 설치한 다음에
다시 @nestjs/devtools-intergration 설치를 시도했는데 잘 넘어갔다!&lt;/p&gt;
&lt;h3&gt;3. graphql 관련 패키지들 업그레이드의 사이드이펙트(?)&lt;/h3&gt;
&lt;p&gt;@nestjs/graphql 패키지를 &lt;code class=&quot;language-text&quot;&gt;10.1.7&lt;/code&gt;에서 &lt;code class=&quot;language-text&quot;&gt;11.0.5&lt;/code&gt;로 업데이트를 하고 나니
&lt;code class=&quot;language-text&quot;&gt;GraphQLModule.forRoot&lt;/code&gt;의 첫번째 인자로 전달하는 options 타입인 ApolloDriverConfig가 변경이 되었는지,
기존에 사용하던 cors와 debug 필드가 오류를 발생하고 있었다..
어떻게 변경되어서 어떻게 사용해야하는지 열심히 찾아봐야하는 상황..!&lt;/p&gt;
&lt;h4&gt;cors&lt;/h4&gt;
&lt;p&gt;cors 관련 내용은 &lt;a href=&quot;https://github.com/nestjs/graphql/issues/2752&quot;&gt;nestjs/graphql 레포지토리의 issues&lt;/a&gt;에서 발견하게 되었다.
Nestjs에서 graphql 사용할 때에는 GraphQLModule에 따로 적어줬어야 했는데 이제는 Nestjs/common에서 제공해주는 &lt;code class=&quot;language-text&quot;&gt;enableCors()&lt;/code&gt;를 같이 사용하면 된다고 한다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;typescript&quot;&gt;&lt;pre class=&quot;language-typescript&quot;&gt;&lt;code class=&quot;language-typescript&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;const&lt;/span&gt; app &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;await&lt;/span&gt; NestFactory&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;create&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;AppModule&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;

app&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;enableCors&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
  origin&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  methods&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token string&quot;&gt;&quot;GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS&quot;&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
  credentials&lt;span class=&quot;token operator&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;token boolean&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;debug&lt;/h4&gt;
&lt;p&gt;이 옵션은 요청에서 오류가 발생했을 때 response로 stacktrace를 전달해줄지에 대한 옵션이였다.
클라이언트에게 stacktrace까지 제공하는 것은 일반적을 권장되지 않는다 하여 &lt;code class=&quot;language-text&quot;&gt;debug: false&lt;/code&gt;로 사용하고 있었는데 이 옵션이 사라져버렸다..!!
아무리 검색을 해도 안나오고(ㅠㅠ) ApolloDriverConfig 타입을 봐도 못찾은 상황에서
그래 없을리가 없지..! 하고 다시 천천히 ApolloDriverConfig에서 extends하고 있는 타입들을 살펴보니 눈에 띄는 필드가 하나 발견되었다.
바로 &lt;code class=&quot;language-text&quot;&gt;includeStacktraceInErrorResponses&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;굉장히 직관적인 이름으로 변경이 되어있었다ㅋㅋㅋㅋㅋ
다행히 잘 찾아내서 추가해주니 이전과 동일하게 stacktrace는 제거가 잘 되었다.. 휴..&lt;/p&gt;
&lt;h3&gt;결말&lt;/h3&gt;
&lt;p&gt;변경 후 devtools는 어떻게 사용하는거지? 싶어서 다시한번 &lt;a href=&quot;https://docs.nestjs.com/devtools/overview&quot;&gt;공식문서&lt;/a&gt;를 읽어보았다.
snapshot 추가하고 DevtoolsModule 추가해주고 하면 사용할 수 있는 줄 알았는데
&lt;a href=&quot;https://devtools.nestjs.com/&quot;&gt;https://devtools.nestjs.com/&lt;/a&gt; 을 들어가서 로그인을 하니까 유료였다.....
그냥 쓸 수 있는 줄 알고 바꾸자고 하셨던 것 같은데 알고보니 유료ㅠㅠ
결국 devtools 사용은 안하는걸로 하고 어쩌다보니 nestjs 버전 업데이트와 graphql 버전 업데이트만 진행하게 된 슬픈지만 좋은 결말..?&lt;/p&gt;
&lt;p&gt;이상 만약 우리처럼 위의 옵션을 사용하고 있다가 업데이트 하고 보니 사라져서 어떻게 해야하나 싶은 분들을 위해 남기는 글이였습니다..&lt;/p&gt;</content:encoded></item><item><title><![CDATA[인터넷과 웹]]></title><description><![CDATA[시리즈는 기초를 위한 것이기도 하지만 새로 들어오실 신입분들에게 진행될 OJT에 피드백을 드릴 수 있기 위해 나부터도 다시 공부해야 할 것 같아서 시작한다.  인터넷과 웹 먼저 인터넷과 웹에 대해 간단하게 알아보자 인터넷 ( Internet…]]></description><link>https://yujuck.github.io/230607-인터넷과 웹/</link><guid isPermaLink="false">https://yujuck.github.io/230607-인터넷과 웹/</guid><pubDate>Wed, 07 Jun 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;Back to Basics&lt;/code&gt; 시리즈는 기초를 위한 것이기도 하지만 새로 들어오실 신입분들에게 진행될 OJT에 피드백을 드릴 수 있기 위해 나부터도 다시 공부해야 할 것 같아서 시작한다. &lt;br /&gt;&lt;/p&gt;
&lt;h2&gt;인터넷과 웹&lt;/h2&gt;
&lt;p&gt;먼저 인터넷과 웹에 대해 간단하게 알아보자&lt;/p&gt;
&lt;h3&gt;인터넷 ( Internet )&lt;/h3&gt;
&lt;p&gt;인터넷이란 여러 통신망을 하나로 연결한다는 의미의 인터 네트워크( inter-network ) 라는 말에서 시작되어, 지금은 전 세계 컴퓨터들을 하나로 연결하는 거대한 컴퓨터 통신망을 의미한다.&lt;/p&gt;
&lt;p&gt;1960년, 미국에서 핵에 의해 중앙집중화된 통신이 마비될 것에 대비하여 통신망을 분산시키기 위해 구축하게 된 것이 인터넷의 시작이다.&lt;br /&gt;
1983년, TCP/IP를 공식 프로토콜로 도입하면서 현대적인 컴퓨터 네트워크의 기본 구조가 갖춰졌고, 이 때 즈음 &apos;인터넷&apos;이 &apos;인터네트워크&apos;의 약자가 아닌 고유명사 취급을 받기 시작했다고 한다.&lt;br /&gt;
web이 나타나기 전 인터넷은 기업이나 연구소, 대학, 군대와 같은 기관에서 사용하던 통신 시스템이여서 대중적이지 않았다.&lt;/p&gt;
&lt;h3&gt;웹 ( Web )&lt;/h3&gt;
&lt;p&gt;월드 와이드 웹 ( World Wide Web ) 이란 인터넷에 연결된 사용자들이 서로의 정보를 공유할 수 있는 공간을 의미한다.
줄여서 WWW나 W3라고도 부르며, 간단하게 웹(Web) 이라고 가장 많이 부른다.&lt;/p&gt;
&lt;p&gt;1989년, 팀 버너스 리 라는 사람이 문자 및 그림, 음성 등 다양한 데이터를 포함한 방대한 데이터베이스를 구축한 뒤, 이를 시각적으로 표현할 수 있는 표준 문서 형식을 규정하고 문서 속에 연결된 특정 항목은 또 다른 문서로 연결되는 정보 검색 시스템을 제시했고,
이것이 &apos;월드 와이드 웹&apos; 이라는 세계적인 정보 공유 공간 및 하이퍼 텍스트 방식의 HTML의 개념이 등장하게 되는 계기가 되었다.&lt;/p&gt;
&lt;p&gt;1991년에는 세계 최초 홈페이지가 공개되었다. (&lt;a href=&quot;http://info.cern.ch/&quot;&gt;http://info.cern.ch/&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;팀 버너스 리는 URL, HTTP, NEXUS(세계 최초 웹브라우저) 등의 설계 및 규격 제정에 참여하면서 웹의 아버지라고 불리게 되었다고 한다.&lt;/p&gt;
&lt;h3&gt;인터넷과 웹의 관계&lt;/h3&gt;
&lt;p&gt;인터넷과 웹은 정확히 말하면 다른 개념이다.&lt;/p&gt;
&lt;p&gt;웹은 인터넷 서비스 중 하나일 뿐이고, 웹 이외에 인터넷에서 제공하는 서비스는 &lt;code class=&quot;language-text&quot;&gt;FTP&lt;/code&gt;, &lt;code class=&quot;language-text&quot;&gt;Email&lt;/code&gt; 등이 있다.
인터넷은 전 세계를 연결시켜주는 네트워크 인프라이고, 이런 인터넷을 기반으로 제공되는 서비스 중 하나가 웹인 것이다.&lt;/p&gt;
&lt;h2&gt;인터넷의 동작 원리&lt;/h2&gt;
&lt;p&gt;백엔드 로드맵에 맨 처음에 위치하는 인터넷의 동작 원리..!&lt;br /&gt;
MDN 문서를 한번 읽어보았다.&lt;/p&gt;
&lt;h3&gt;단순한 네트워크&lt;/h3&gt;
&lt;p&gt;두 개의 컴퓨터가 통신을 할 때, 다른 컴퓨터와 물리적(이더넷 케이블) 또는 무선(Wi-Fi, 블루투스)으로 연결이 되어야 한다.&lt;/p&gt;
&lt;p&gt;이런 네트워크는 원하는 만큼의 컴퓨터를 연결할 수 있지만 여러 개의 컴퓨터를 연결할 수록 복잡해진다. (필요한 물리적 자원이 늘어남)&lt;/p&gt;
&lt;p&gt;이런 문제를 해결하기 위해 사용하는 것이 &lt;code class=&quot;language-text&quot;&gt;라우터&lt;/code&gt;이다. 라우터는 특수한 소형 컴퓨터로 A 컴퓨터에서 B 컴퓨터에 요청을 보냈을 때, B 컴퓨터로 잘 도착하도록 해준다.
따라서 각 컴퓨터는 하나의 라우터에 연결되어 서로 통신할 수 있게 된다.&lt;/p&gt;
&lt;h3&gt;네트워크 속의 네트워크&lt;/h3&gt;
&lt;p&gt;이제 좀 더 확장시켜서 수십억 대의 컴퓨터를 연결하는 상황을 생각해보자.
단일 라우터는 수십억 대의 컴퓨터를 연결하는 정도로 확장할 수는 없지만
라우터도 마찬가지로 컴퓨터라고 했기 때문에 서로 다른 두 대의 라우터를 연결할 수 있다.
컴퓨터를 라우터에 연결하고, 라우터에서 라우터로 연결하여 무한하게 확장시킬 수 있다.&lt;/p&gt;
&lt;p&gt;네트워크의 네크워크를 구현해 하나의 통신망으로 연결하는 것이 인터넷인데, 위의 방법으로는 먼 곳의 지역과는 연결이 불가능하다.
따라서 전화기 기반 시설을 사용하여 범위를 더 확장시킨다.
전화기 기반 시설은 이미 서계 어느 곳과도 연결되어있기 때문에 전화 시설과 연결하는 것이고, 이를 위해서는 &lt;code class=&quot;language-text&quot;&gt;모뎀&lt;/code&gt;이라는 장비가 필요하다.
모뎀은 네트워크의 정보를 전화 시설에서 처리할 수 있는 정보로 바꿔주고 그 반대의 경우도 마찬가지이다.&lt;/p&gt;
&lt;p&gt;이제 현재 네트워크에서 다른 네트워크로 메세지를 보내는데, 이를 위해서 네트워크를 인터넷 서비스 제공 업체(Internet Service Provider, ISP)에 연결한다.
(ISP의 예시로는 KT, SK텔레콤, LG유플러스 등이 있다.)
ISP는 모두 함께 연결되는 몇몇 특수한 라우터를 관리하고 다른 ISP의 라우터에도 액세스할 수 잇는 회사이다.
따라서 현재 네트워크의 메세지는 ISP 네트워크의 네트워크를 통해 대상 네트워크로 전달되고, 인터넷은 이러한 전체 네트워크 인프라로 구성된다.&lt;/p&gt;
&lt;h3&gt;중간 요약&lt;/h3&gt;
&lt;p&gt;컴퓨터 - 라우터 - 모뎀 - 전화시설 - ISP 이렇게 연결되어 다른 컴퓨터와 통신할 수 있게 된 것.&lt;br /&gt;
각 단계는 연결을 확장시키는 단계에서 추가되었다. (두 대의 컴퓨터 연결에서 전 세계 컴퓨터 연결로의 확장)&lt;/p&gt;
&lt;h3&gt;컴퓨터 찾기&lt;/h3&gt;
&lt;p&gt;다른 컴퓨터에 메세지를 보내려면 수신할 컴퓨터를 지정해야한다. 따라서 네트워크에 연결된 모든 컴퓨터에는 IP 주소라는 고유한 주소가 있다.
컴퓨터는 IP 주소로 다른 컴퓨터를 찾는데 문제가 없지만 사람은 IP 주소를 기억하기 어렵기 때문에 &apos;도메인&apos; 이라는 사람이 읽을 수 있는 형태의 IP 주소 이름을 지정할 수 있다.&lt;/p&gt;
&lt;h2&gt;마무리&lt;/h2&gt;
&lt;p&gt;인터넷과 웹이라는 단어는 일상에서 굉장히 많이 사용하기도 하고 아무래도 웹 개발자로서 언젠가 분명 이런 내용을 읽은 것 같긴 한데 이번에 새삼 좀 재미있게 읽었다.&lt;br /&gt;
일단 웹이라는 개념이 팀 버너스 리 라는 한 사람의 머리에서 나와서 지금까지 꾸준히 발전해온게 진짜 뭔가 대단하고 새삼 느낌..&lt;br /&gt;
URL이랑 HTTP까지.. 어떻게 한 사람이 다..?&lt;br /&gt;
그리고 생각보다 굉장히 오래 전에 인터넷이라는 개념이 생긴 것도 신기했다. &lt;br /&gt;1960년.. 한반도 전쟁 휴전된 게 53년인데.. 7년 뒤에 인터넷..? 그걸 지금까지도..? 이런 느낌이라 재밌었다.&lt;/p&gt;
&lt;p&gt;참고&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.youtube.com/watch?v=pYOEy_mAMpI&amp;#x26;list=PLuHgQVnccGMDZP7FJ_ZsUrdCGH68ppvPb&amp;#x26;index=16&quot;&gt;생활코딩&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://terms.naver.com/entry.naver?docId=3573476&amp;#x26;cid=59088&amp;#x26;categoryId=59096&quot;&gt;인터넷&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/ko/docs/Learn/Common_questions/Web_mechanics/How_does_the_Internet_work&quot;&gt;인터넷은 어떻게 동작하는가?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[새로운 시작]]></title><description><![CDATA[prologue '개발자' 라는 직업을 갖게 된 지 벌써…]]></description><link>https://yujuck.github.io/230606/</link><guid isPermaLink="false">https://yujuck.github.io/230606/</guid><pubDate>Tue, 06 Jun 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;prologue&lt;/h2&gt;
&lt;p&gt;&apos;개발자&apos; 라는 직업을 갖게 된 지 벌써 3년 반이라는 시간이 지났다.
깊은 고민과 생각 없이 흘러가는대로 시작하게 되어서 그런지, 지난 시간들도 &apos;마냥 흘려보낸 것만 같다&apos; 라는 생각을 요즘 굉장히 많이 하고 있다.&lt;/p&gt;
&lt;p&gt;물론 진짜로 무념무상 흘려보낸건 아니긴 하지.
내가 맡은 일을 할 때 매 순간 많은 고민과 해결책을 찾으면서 일했고, 분명 처음 시작했을 때보다는 아는건 많아졌을거라 생각한다.
그럼에도 지금 느끼고 있는 지난 시간들에 대한 후회는 무엇 때문일까.
후회인지 회의감인지 뭔지 모를 감정에 휩쓸리고 있는게 현재 내 상태..&lt;/p&gt;
&lt;p&gt;이런 상황에서 새롭게 블로그를 만들어 글을 써보려고 하는 것은 하루하루 기록을 남기면서 나 자신에 대해서도 생각을 해보고,
개발하면서 보고 배운 내용들도 정리를 해보기 위해서이다.
분명 좋은 팀을 만나 3년 6개월동안 많은 것을 배웠는데 글로써 남아있는 것이 별로 없다보니 내가 무엇을 어떻게 했었는지 생각해내는 것이 어렵기도 하고,
분명 일할 때 찾아보면서 적용시킨 내용들인데 오랫동안 기억에 남지 않아 같은 내용이더라도 찾아보게 되는 순간들이 있어서
이젠 정말 기록을 잘 남겨보려고 한다.&lt;/p&gt;
&lt;h3&gt;고민&lt;/h3&gt;
&lt;p&gt;요즘 고민을 하고 있는건 나에게 &apos;개발자&apos;라는 직업이 잘 맞는건가? 하는 것인데 사실 잘 모르겠다.
애초에 정말 싫다 싶었으면 학부 때 전공으로 선택을 안했을 것이고, 취업 준비할 때에도 선택지에서 제외를 시켰을 것 같은데
&apos;개발&apos; 자체가 선택지에 없었던 적이 없긴 하다.
그냥 다들 원래 무난하게 전공 살려서 취업하는거 아니야? 라고 생각하며 살았는데
&apos;개발자&apos;라는 직업을 정말 하고 싶어서 시작하는 사람들을 보다 보니 이런 고민을 하게 되는 것 같다.
(이게 지금 후회인지 회의감인지 뭔지 모를 그 감정의 원인인 듯..!)&lt;/p&gt;
&lt;p&gt;3년 6개월이라는 기간 중에 이런 생각을 한게 이번이 처음은 아니었다.
뭔가 내가 무능력하다고 느껴지거나 나에 대한 확신이 없어질 때마다 이런 생각을 한 것 같긴 하다.
언제인지 기억은 안나지만 한 1년 안되었을 때였던 것 같긴 한데
회사에서 내가 맡은 일 중에 정말 안풀리고 어떻게 해야할지 모르겠는 일이 있었을 때,
지금 와서 생각해보면 동기나 사수나 팀장님한테 솔직하게 말했어도 좋았겠다 싶지만
그때의 나는 회사에서 순간순간 터지려는 눈물을 참으면서 하기도 했다.
일은 잘 해결되었지만 이런 상황이 있을 때마다 나는 &apos;내가 정말 잘하고 있는걸까?&apos;라는 생각을 했던 것 같다.&lt;/p&gt;
&lt;p&gt;이런 생각을 진짜 요즘 매일 하게 되는데 그러다보니 좀 지쳐서..
일단은 개발 공부에 시간을 투자해보자! 가 결론이 되었다.
일할 때 정말 행복해 죽을 것처럼 하면 물론 좋겠지만 현재의 나는 일단 그런 사람은 아니다.
그렇다고 잘하고 싶은 욕심이 없는 것도 아니다..
잘하고 싶은 욕심이 없었으면 그냥 되는대로 살았을 것 같은데 그렇지는 않았다고 생각한다.
나름 책도 읽고 강의도 들으면서 지식을 쌓으려고 노력도 하고
새로운 기술 적용할 때도 &apos;아.. 나는 진짜 능력이 없나.. 왜이렇게 못하냐..&apos; 라고 생각하면서도 결국엔 하긴 하는걸 보면 그냥 평균 정도는 하지 않나 싶은..
그래서 일단은 개발 공부에 들이는 시간을 늘려보면 자기 확신이 생기지 않을까 싶어 새롭게 블로그도 만든 것.&lt;/p&gt;
&lt;p&gt;개발 관련 공부도 하면서 내가 뭘 좋아하는지 찾아보는 것도 끊임없이 시도해볼 생각이다.
스스로에게 질문을 했을 때 &apos;모르겠다&apos; 라는 답이 많은 인간이다.
내가 나한테 질문하는데 왜 모르지? 나는 왜 내 자신이 제일 어렵지?
이게 진짜로 모르는건지 아니면 내 자신조차 속이는건지 정말로 &apos;모르겠다&apos;...
너무 어려워.. 어쩌다 이런 인간이 되어버린건지 모르겠지만
조금 더 자신에게 솔직한 사람이 되기 위해 고민도 많이 해보려고 한다.
최대한 &apos;모르겠다&apos;라는 답을 하지 않기 위해 노력하는게 1순위일 듯ㅠㅠ&lt;/p&gt;
&lt;h3&gt;마무리&lt;/h3&gt;
&lt;p&gt;첫 게시글이 이런.. 고민만 잔뜩 적은 글이 되어버렸지만 중요한 과정이라고 생각한다. 나 자신을 찾는 것과 개발에 시간을 투자하는 것 모두.
최근에 두 분께 &apos;다재다능한 면이 있다&apos; 라는 말과 &apos;잠재력이 충분히 있는 사람이다&apos; 라는 말이 굉장히 감사했고 눈물이 날 것 같았다. 나는 이렇게 내 자신에 대해 확신이 없고 자신감이 없는데 이렇게 봐주는 사람도 있네 싶어서 왜인지 미안한 느낌도 들었다. 지금은 이런 얘길 들어도 없던 확신이 생기지 않지만 하고 싶은 게 확실해졌을 때, 이런 말도 자신있게 받아들일 수 있는 사람이 되고 싶다. 30살 이전엔 한번 찾아보자고! 이제 만나이로 바뀌니까 아직 1년 남았다!!!😂😂&lt;/p&gt;</content:encoded></item></channel></rss>