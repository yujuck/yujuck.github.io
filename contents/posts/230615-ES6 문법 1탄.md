---
title: "ES6(ECMAScript 6) 알아보기 - let, const, 화살표 함수, 스프레드 연산자"
date: 2023-06-15
update: 2023-06-15
tags:
  - javascript
  - ES6
series: ECMAscript
---

지금은 기본 중의 기본이 되어있는 ES6인데 글을 쓰는 이유는..?  
ES6 이후에 나온 내용들도 한번 쭉 보고 싶어서 시리즈로 만들기 위해 적어보려고 한다!

## ECMAScript? ES?

> Ecma International이 `ECMA-262`기술 규격에 따라 정의하고 있는 표준화된 스크립트 프로그래밍 언어

Javascript는 Netscape 회사의 Brendan Eich 라는 사람에 의해 최초로 개발되었다. 그 후 Javascript의 성공에 자극을 받은 마이크로소프트는 Jscript 라는 언어를 개발하고 IE에 지원되기 시작했다.  
두 스크립트가 서로 호환되지 못하는 경우가 생기게 되면서 표준화가 요구되었고, ECMA-262의 이름으로 1996년 11월부터 시작됐다.

`ES`는 `ECMAScript의 약자`다. 헷갈릴 수 있는 게 `ES6`는 ES016이 아니라 `ES2015`와 `동일`하다.
현재는 ES6보다 더 많은 버전이 나와있는데도 최신 버전의 내용보다 ES6의 내용을 중요하게 보는 데에는 이유가 있다.

먼저, ES6에 추가된 개념들이 ES6 이하 버전에서 문제가 되었던 부분들이 해결되고 많은 기능이 추가되어 현재까지도 중요한 개념들이기 때문이다. 그리고 구버전의 웹 브라우저나 레거시 코드와의 호환성 문제가 있어 대부분의 기업들이 ES6까지를 호환성의 최대치로 보고 있다고 한다.

## ES6 하나씩 알아보기

### let, const

이제는 너무 기본적인 `let` 과 `const`.

블록 스코프의 변수 선언을 할 수 있게 되었다. var와의 가장 큰 차이점이 바로 함수 스코프가 아닌 블록 스코프 변수 선언이라는 것이다.

`let`과 `const`의 차이점은 const는 한번 초기화하면 다른 값을 정의할 수 없지만 let은 계속 값을 변경할 수 있다. 주의할 점은 const여도 객체나 배열의 요소의 변경을 막진 않는 다는 것이다.

호이스팅에 대한 얘기도 무조건 나온다.

var 키워드와 달리 let과 const는 변수 호이스팅이 발생하지 않는 것처럼 동작한다.

```
console.log(x);  // ReferenceError
let x;
```

var 키워드로 선언했다면 위의 상황에서 ReferenceError가 아닌 undefined가 출력되었을 것이다.  
`var` 키워드 변수는 런타임 이전에 선언 단계와 초기화 단계가 `한번에 진행`되는데,  
`let` 키워드 변수는 선언 단계와 초기화 단계가 `분리되어 진행`된다.  
즉, 런타임 이전에 선언 단계가 먼저 실행되지만 `초기화 단계는 변수 선언문에 도달했을 때 실행`된다.

초기화 단계가 실행되기 이전에 변수에 접근하려고 하면 참조 에러(ReferenceError)가 발생한다.  
let 키워드 변수는 스코프 시작 지점부터 초기화 단계가 실행되는 변수 선언문까지는 변수를 참조할 수 없는데,
이 구간을 `일시적 사각지대`(Temporal Dead Zone: TDZ) 라고 한다.

위의 특성 때문에 변수 호이스팅이 발생하지 않는 것처럼 보이지만 그렇지는 않다.

```
let x = 1;  // 전역변수
{
    console.log(x);  // ReferenceError
    let x = 2;  // 지역변수
}
```

변수 호이스팅이 발생하지 않는다면 위 예제는 전역 변수 x의 값을 출력해야하는데,
그렇지 않고 ReferenceError가 발생한다.  
-> 호이스팅이 발생했기 때문에 지역 변수 x의 존재를 알고 있지만 값이 초기화 되어있지 않아서 ReferenceError가 발생

자바스크립트는 ES6에서 도입된 let, const를 포함해서 모든 선언(var, let ,const, function, class 등)을 호이스팅 한다.  
단, ES6에서 도입된 let, const class를 사용한 선언문은 호이스팅이 발생하지 않는 것처럼 동작한다.

### 화살표 함수 (Arrow Function)

```javascript
// ES5
var x = function (x, y) {
  return x * y;
};

// ES6
const x = (x, y) => x * y;
```

화살표 함수의 가장 큰 특징은 `this`가 상위 스코프의 this로 유지가 된다는 것이다.
항상 익명함수로 정의하고, 생성자 함수로 사용할 수도 없다. 또한 prototype 프로퍼티가 없고 arguments 객체를 생성하지 않는다는 특징이 있다.

### 스프레드 연산자 (Spread Operator)

스프레드 연산자 (...) 은 반복 가능한(iterable) 객체에 적용할 수 있는 문법이다. 배열, 문자열 등의 요소 하나하나를 spread 시켜주는 문법이다.

```javascript
const arr = [1, 2, 3, 4];

console.log(...arr); // 1, 2, 3, 4
```

스프레드 연산자는 여러 배열을 하나로 합칠 때도 유용하다.

```javascript
const arr1 = ["a", "b", "c"];
const arr2 = ["d", "e", "f"];

const result = [...arr1, ...arr2]; // ['a', 'b', 'c', 'd', 'e', 'f']
```

객체도 iterable 하기 때문에 스프레드 연산자를 사용할 수 있다.

```javascript
const obj = {
  a: 1,
};

const obj2 = { ...obj }; // { a: 1 }
```

이때 깊은 복사 즉, obj와 obj2는 다른 주소값을 가지게 되는데(obj를 변경해도 obj2가 변하지 않음), 이런 깊은 복사는 1depth에 한해서만 가능하다.

```javascript
const numbers = [23, 55, 21, 87, 56];
let maxValue = Math.max(...numbers);
```

배열의 요소를 함수의 인자로 사용하려는 경우, 위처럼 작성할 수 있고

```javascript
function myFunction(v, w, x, y, z) {}
const args = [0, 1];
myFunction(-1, ...args, 2, ...[3]);
```

이렇게 여러 번 사용할 수도 있다.

참고

- [ECMA스크립트](https://ko.wikipedia.org/wiki/ECMA%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8)
- [ES6](https://velog.io/@krungy/ES6)
- [Javascript ES6](https://www.w3schools.com/js/js_es6.asp)
- [ECMAScript](https://www.zerocho.com/category/ECMAScript)
